<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../../css/style.css" />
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Georgia, 'Times New Roman', serif;
            background-color: #f8f5f2;
            color: #333;
            line-height: 1.6;
        }

        .tei-page {
            max-width: 700px;
            margin: auto;
            padding: 3em 1.5em;
            position: relative;
        }

        h1 {
            font-size: 2em;
            margin-bottom: 1em;
            padding-bottom: 0.3em;
            border-bottom: none;
            position: relative;
        }

        h1::after {
            content: "";
            display: block;
            margin-top: 0.5rem;
            width: 100%;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(90, 74, 56, 0.4), transparent);
        }

        p {
            margin-bottom: 2em;
        }

        a {
            text-decoration: none;
            color: #0066cc;
            font-weight: bold;
            transition: color 0.3s ease;
        }

        a:hover {
            color: #004499;
        }

        ul {
            list-style: none;
            padding: 0;
        }

        li {
            background: #fff;
            padding: 1em;
            margin-bottom: 1em;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.06);
            transition: transform 0.2s ease;
        }

        li:hover {
            transform: translateY(-2px);
        }

        .no-link {
            color: #aaa;
            text-decoration: line-through;
            cursor: not-allowed;
            font-style: italic;
        }

        /* New CSS for the home icon */
        .home-link {
            position: absolute;
            top: 1em;
            left: -100px;
            /* Move it outside the left margin */
        }

        .home-link img {
            width: 88px;
            height: auto;
            border-radius: 4px;
            cursor: pointer;
            background-color: #fff;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
        }

        .home-link img:hover {
            box-shadow: 0 0 8px rgba(0, 0, 0, 0.3);
        }

        .legacy-back {
            margin: 0 0 1.2rem;
        }

        .legacy-back-button {
            border: none;
            border-radius: 8px;
            padding: 0.45rem 0.8rem;
            background: #f6efe5;
            color: #4a3e30;
            font-family: Georgia, serif;
            cursor: pointer;
            box-shadow: 0 3px 0 rgba(74, 62, 48, 0.22);
            transition: transform 0.15s ease, box-shadow 0.15s ease, background-color 0.2s ease;
        }

        .legacy-back-button:hover {
            background: #f3ece2;
        }

        .legacy-back-button:active {
            transform: translateY(1px);
            box-shadow: 0 1px 0 rgba(74, 62, 48, 0.22);
        }

        .xml-link-block {
            margin-top: 1.6rem;
            font-size: 0.88rem;
            color: #5a4d3d;
            display: inline-block;
        }

        .xml-link-block a {
            font-size: 0.88rem;
            color: #4b3a23;
            text-decoration: none;
            font-weight: 600;
        }

        .xml-link-block a:hover {
            text-decoration: underline;
        }

        .xml-link-block::after {
            content: "";
            display: block;
            margin-top: 0.45rem;
            width: 70%;
            height: 1px;
            background: linear-gradient(90deg, rgba(90, 74, 56, 0.6), transparent);
        }
    </style>
</head>

<body>
    <header class="site-header">
        <div class="logo-container">
            <img src="../../assets/logo.png" class="logo-icon" width="50" height="50" loading="eager" decoding="async"
                alt="MATHesis logo" />
            <img src="../../assets/logotype.svg" class="letter-logo" width="140" height="32" loading="eager"
                decoding="async" alt="MATHesis" />
        </div>
        <nav class="site-nav">
            <a href="../../">Home</a>
            <a href="../../search/">Search</a>
            <a href="../../transcriptions/">Transcriptions</a>
            <a href="../../visualization/">Visualization</a>
            <a href="../../map/">Map</a>
            <a href="../../about/">About</a>
        </nav>
    </header>

    <main class="tei-page">
        <div class="legacy-back">
            <button id="legacyBackButton" class="legacy-back-button" type="button">Back</button>
        </div>
        <div id="tei-container"></div>
        <div class="xml-link-block">
            <a href="./lingyue.xml" target="_blank" rel="noopener">view XML</a>
        </div>
    </main>
    <script type="module">
        async function loadTEI(fileName, targetSelector) {
            const target = document.querySelector(targetSelector);
            if (!target) throw new Error("Target element not found: " + targetSelector);

            try {
                const res = await fetch(`./${fileName}`, { headers: { "Accept": "application/xml" } });
                if (!res.ok) throw new Error(`HTTP ${res.status} for ${fileName}`);
                const xmlText = await res.text();

                // Parse XML (TEI usually uses a default namespace)
                // Parse XML and strip namespace manually to preserve all TEI tags
                const parser = new DOMParser();
                let xmlTextNoNS = xmlText.replace(/xmlns="[^"]+"/, "");  // ğŸ‘ˆ å»æ‰é»˜è®¤ namespace
                const xml = parser.parseFromString(xmlTextNoNS, "text/xml");


                // Basic parse error check
                if (xml.getElementsByTagName("parsererror").length) {
                    throw new Error("XML parse error");
                }

                // Render TEI â†’ HTML
                const html = teiNodeToHTML(xml.documentElement);
                target.innerHTML = "";
                target.appendChild(html);
                await runNodeHighlightPrototype(target, fileName);
            } catch (err) {
                console.error(err);
                // Fallback: show raw XML safely
                target.textContent = "Failed to render TEI. Showing raw XML:\n\n" + (err?.message || "");
                try {
                    const res2 = await fetch(`./${fileName}`);
                    const raw = await res2.text();
                    target.textContent += "\n\n" + raw;
                } catch { }
            }
        }

        async function runNodeHighlightPrototype(container, sourceFileName) {
            try {
                const terms = await loadNodeTermsForPrototype();
                const stats = highlightNodeTerms(container, terms);
                renderHitSummary(stats);
                console.log(`[Node highlight prototype] file=${sourceFileName} totalHits=${stats.totalHits} matchedTerms=${stats.matchedTerms} dictionarySize=${terms.length}`);
                if (stats.topHits.length) console.table(stats.topHits);
            } catch (err) {
                console.warn("[Node highlight prototype] failed:", err);
                renderHitSummary({ totalHits: 0, matchedTerms: 0, dictionarySize: 0, failed: true, topHits: [] });
            }
        }

        async function loadNodeTermsForPrototype() {
            const path = window.location.pathname || "";
            const basePrefix = path.includes("/transcriptions/") ? path.split("/transcriptions/")[0] : "";
            const dataUrl = `${basePrefix}/data.json`;
            const mapUrl = `${basePrefix}/simp_to_trad_map.json`;
            const res = await fetch(dataUrl, { headers: { "Accept": "application/json" } });
            if (!res.ok) throw new Error(`HTTP ${res.status} for ${dataUrl}`);
            const data = await res.json();
            const nodes = Array.isArray(data?.nodes) ? data.nodes : [];

            const terms = new Set();
            const splitRegex = /[\s,/;:()[\]{}|]+/;
            const zhNumerals = new Set(["ä¸€", "äºŒ", "ä¸‰", "å››", "äº”", "å…­", "ä¸ƒ", "å…«", "ä¹", "å"]);
            const arabicToZhNumeral = {
                "1": "ä¸€",
                "2": "äºŒ",
                "3": "ä¸‰",
                "4": "å››",
                "5": "äº”",
                "6": "å…­",
                "7": "ä¸ƒ",
                "8": "å…«",
                "9": "ä¹",
                "10": "å"
            };

            let simpToTrad = {};
            try {
                const mapRes = await fetch(mapUrl, { headers: { "Accept": "application/json" } });
                if (mapRes.ok) {
                    simpToTrad = await mapRes.json();
                }
            } catch {
                simpToTrad = {};
            }
            const tradToSimp = Object.fromEntries(Object.entries(simpToTrad).map(([simp, trad]) => [trad, simp]));

            const toSimp = (s) => Array.from(s).map(ch => tradToSimp[ch] || ch).join("");
            const toTrad = (s) => Array.from(s).map(ch => simpToTrad[ch] || ch).join("");
            const addWithVariants = (term) => {
                terms.add(term);

                const simpTerm = toSimp(term);
                const tradTerm = toTrad(term);
                if (simpTerm) terms.add(simpTerm);
                if (tradTerm) terms.add(tradTerm);

                // Generate limited mixed variants to catch hybrid forms like "é»„é˜".
                const chars = Array.from(term);
                const options = chars.map(ch => {
                    const opts = new Set([ch, tradToSimp[ch] || ch, simpToTrad[ch] || ch]);
                    return Array.from(opts);
                });
                const convertibleCount = options.filter(opts => opts.length > 1).length;
                if (chars.length > 6 || convertibleCount > 4) return;

                const build = (i, acc) => {
                    if (i === options.length) {
                        terms.add(acc);
                        return;
                    }
                    for (const ch of options[i]) {
                        build(i + 1, acc + ch);
                    }
                };
                build(0, "");
            };

            const add = (raw) => {
                if (typeof raw !== "string") return;
                const term = raw.trim().replace(/\s+/g, " ");
                if (!term) return;
                if (/^\d+$/.test(term)) {
                    // Never match Arabic numerals directly, but map 1-10 to Chinese numerals.
                    const mapped = arabicToZhNumeral[term];
                    if (mapped) addWithVariants(mapped);
                    return;
                }

                const hasCJK = /[\u3400-\u9fff]/u.test(term);
                if (hasCJK && term.length < 2 && !zhNumerals.has(term)) return;
                if (!hasCJK && term.length < 3) return;
                addWithVariants(term);

                // Prototype-only fuzzy aliases so we can see visible hits quickly.
                if (hasCJK && term.length >= 3) {
                    addWithVariants(term.slice(0, 2));
                    addWithVariants(term.slice(0, 3));
                }
            };

            for (const node of nodes) {
                const p = node?.properties || node || {};
                const candidates = [p.name, p.name_zh, p.name_zh_simple, p.name_en, p.name_sa, p.transliteration];
                for (const value of candidates) {
                    add(value);
                    if (typeof value === "string" && splitRegex.test(value)) {
                        value.split(splitRegex).forEach(add);
                    }
                }
            }

            return Array.from(terms).sort((a, b) => b.length - a.length).slice(0, 2000);
        }

        function escapeRegex(s) {
            return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        }

        function highlightNodeTerms(container, terms) {
            if (!terms.length) return { totalHits: 0, matchedTerms: 0, topHits: [], dictionarySize: 0 };
            const regex = new RegExp(terms.map(escapeRegex).join("|"), "gu");
            const counts = new Map();
            let totalHits = 0;

            const walker = document.createTreeWalker(
                container,
                NodeFilter.SHOW_TEXT,
                {
                    acceptNode(node) {
                        if (!node.nodeValue || !node.nodeValue.trim()) return NodeFilter.FILTER_REJECT;
                        const parent = node.parentElement;
                        if (!parent) return NodeFilter.FILTER_REJECT;
                        if (parent.closest("h1")) return NodeFilter.FILTER_REJECT;
                        if (parent.closest("script, style, a, button, code, pre, .tei-node-hit")) return NodeFilter.FILTER_REJECT;
                        return NodeFilter.FILTER_ACCEPT;
                    }
                }
            );

            const targets = [];
            let n;
            while ((n = walker.nextNode())) targets.push(n);

            for (const textNode of targets) {
                const text = textNode.nodeValue;
                regex.lastIndex = 0;
                if (!regex.test(text)) continue;
                regex.lastIndex = 0;

                const frag = document.createDocumentFragment();
                let cursor = 0;
                for (const m of text.matchAll(regex)) {
                    const term = m[0];
                    const start = m.index || 0;
                    const end = start + term.length;

                    if (start > cursor) frag.appendChild(document.createTextNode(text.slice(cursor, start)));
                    const mark = document.createElement("span");
                    mark.className = "tei-node-hit";
                    mark.textContent = term;
                    frag.appendChild(mark);

                    counts.set(term, (counts.get(term) || 0) + 1);
                    totalHits += 1;
                    cursor = end;
                }
                if (cursor < text.length) frag.appendChild(document.createTextNode(text.slice(cursor)));
                textNode.parentNode.replaceChild(frag, textNode);
            }

            const topHits = Array.from(counts.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 20)
                .map(([term, hits]) => ({ term, hits }));

            return { totalHits, matchedTerms: counts.size, topHits, dictionarySize: terms.length };
        }

        function renderHitSummary(stats) {
            const container = document.querySelector(".xml-link-block") || document.body;
            let block = document.getElementById("nodeHitSummary");
            if (!block) {
                block = document.createElement("section");
                block.id = "nodeHitSummary";
                block.className = "node-hit-summary";
                container.insertAdjacentElement("beforebegin", block);
            }
            if (stats.failed) {
                block.textContent = "Node highlight: failed";
                return;
            }
            const items = (stats.topHits || [])
                .map(({ term, hits }) => `<li><code>${term}</code> <span>${hits}</span></li>`)
                .join("");

            block.innerHTML = `
                <div class="node-hit-badge">Node highlight: ${stats.totalHits} hits / ${stats.matchedTerms} terms</div>
                <details class="node-hit-details" open>
                    <summary>Matched terms (top 30)</summary>
                    <ul>${items || "<li><em>No matches</em></li>"}</ul>
                </details>
            `;
        }

        // Minimal TEI â†’ HTML mapping
        function teiNodeToHTML(node) {
            // Text nodes
            console.log("NODE:", node.localName);  // â† è¿™ä¸€è¡Œæ–°åŠ çš„ï¼Œè°ƒè¯•æ ‡ç­¾ç”¨ï¼ˆå³åµŒå¥—çš„XMLç»“æ„èƒ½å¦æ­£ç¡®åœ¨ç½‘é¡µç«¯è¢«æ¸²æŸ“å‡ºæ¥ï¼Œè¿™æ¬¡è§£å†³äº†unclearä¸è¢«æ˜¾ç¤ºä¸ºé—®å·çš„æƒ…å†µï¼‰
            if (node.outerHTML) console.log("RAW:", node.outerHTML);  // â† è¿™ä¸€è¡Œæ–°åŠ çš„ï¼Œä¿ç•™ä¸ºè°ƒè¯•æ¨¡æ¿ï¼Œåœ¨å¤§å‹ XML é¡¹ç›®ä¸­æœ‰åŠ©äºæ’æŸ¥ namespace ä¸¢å¤±ï¼Œå¯æ³¨é‡Šæ‰
            if (node.nodeType === Node.TEXT_NODE) {
                return document.createTextNode(node.nodeValue);
            }

            // Ignore comments and processing instructions
            if (node.nodeType !== Node.ELEMENT_NODE) {
                return document.createDocumentFragment();
            }

            const name = node.localName; // works regardless of TEI namespace
            const frag = document.createDocumentFragment();

            // Helper to render children
            const renderChildren = (parentEl = null) => {
                const container = parentEl || document.createDocumentFragment();
                for (const child of node.childNodes) {
                    container.appendChild(teiNodeToHTML(child));
                }
                return container;
            };

            // Map a few common TEI elements
            switch (name) {
                case "TEI":
                case "teiCorpus": {
                    const wrapper = el("article", "tei-doc");
                    wrapper.appendChild(renderChildren());
                    return wrapper;
                }
                case "teiHeader": {
                    // Skip header in main view but keep title if present
                    const titleStmt = node.getElementsByTagNameNS("*", "titleStmt")[0];
                    const titleEl = titleStmt?.getElementsByTagNameNS("*", "title")[0];
                    if (titleEl) {
                        const h1 = el("h1");
                        h1.textContent = textContentDeep(titleEl);
                        return h1;
                    }
                    return document.createDocumentFragment();
                }
                case "text": {
                    const section = el("section");
                    section.appendChild(renderChildren());
                    return section;
                }
                case "body": {
                    const main = el("div", "tei-body");
                    main.appendChild(renderChildren());
                    return main;
                }
                case "div": {
                    const div = el("section", "tei-div");
                    // optional head within div
                    const head = node.getElementsByTagNameNS("*", "head")[0];
                    if (head) {
                        const h2 = el("h2");
                        h2.textContent = textContentDeep(head);
                        div.appendChild(h2);
                    }
                    for (const child of node.childNodes) {
                        if (child.nodeType === Node.ELEMENT_NODE && child.localName === "head") continue;
                        div.appendChild(teiNodeToHTML(child));
                    }
                    return div;
                }
                case "p": {
                    const p = el("p");
                    p.appendChild(renderChildren());
                    return p;
                }
                case "head": {
                    const h2 = el("h2");
                    h2.appendChild(renderChildren());
                    return h2;
                }
                case "lb": {
                    return el("br");
                }
                case "pb": {
                    const span = el("span", "tei-pb");
                    const n = node.getAttribute("n");
                    const facs = node.getAttribute("facs");
                    span.setAttribute("title", n ? `Page break: ${n}` : "Page break");
                    // æ˜¾ç¤ºä¸­æ€§ç¬¦å·ï¼Œé¿å…å’Œ verse bar æ··æ·†
                    span.textContent = n ? ` [${n}] ` : " [pb] ";
                    return span;
                }
                case "note": {
                    const place = node.getAttribute("place");

                    // â€”â€” A ç±»ï¼šå†…è”æ³¨é‡Šï¼ˆinlineï¼‰ â€”â€”
                    if (place === "inline") {
                        const span = el("span", "tei-note-inline");
                        span.title = "inline note";   // hover tooltip
                        span.appendChild(renderChildren());
                        return span;
                    }

                    // â€”â€” B ç±»ï¼šæ™®é€šè„šæ³¨ï¼ˆä¿ç•™åŸæ ·ï¼‰ â€”â€”
                    const aside = el("aside", "tei-note");
                    aside.appendChild(renderChildren());
                    return aside;
                }

                case "hi": {
                    const rend = node.getAttribute("rend") || "";
                    const tag = /italic|em/.test(rend) ? "em" : /bold|strong/.test(rend) ? "strong" : "span";
                    const elx = el(tag);
                    elx.appendChild(renderChildren());
                    return elx;
                }
                case "q": {
                    const q = el("blockquote");
                    q.appendChild(renderChildren());
                    return q;
                }
                case "list": {
                    const listType = node.getAttribute("type") || "";
                    const ul = el(listType === "ordered" ? "ol" : "ul");
                    ul.appendChild(renderChildren());
                    return ul;
                }
                case "item": {
                    const li = el("li");
                    li.appendChild(renderChildren());
                    return li;
                }
                case "lg": {
                    const div = el("div", "tei-lg");
                    div.appendChild(renderChildren());
                    return div;
                }
                case "l": {
                    const p = el("p", "tei-line");
                    p.appendChild(renderChildren());
                    return p;
                }
                case "ref": {
                    const a = el("a");
                    const href = node.getAttribute("target") || node.getAttribute("url") || "#";
                    a.href = href;
                    a.appendChild(renderChildren());
                    return a;
                }
                case "gap": {
                    // æ˜¾ç¤ºç¼ºå­—ç¬¦å·ï¼Œå¦‚ +++
                    const qty = node.getAttribute("quantity");
                    const span = el("span", "tei-gap");
                    const symbol = "+";
                    span.textContent = qty ? symbol.repeat(Number(qty)) : symbol.repeat(3);
                    return span;
                }

                case "supplied": {
                    // æ˜¾ç¤ºé‡å»ºçš„å†…å®¹ <...>
                    const span = el("span", "tei-supplied");
                    // æ£€æŸ¥æ˜¯å¦åŸæœ¬åŒ…å« <unclear>
                    const hasUnclear = node.getElementsByTagName("unclear").length > 0;
                    const text = textContentDeep(node);
                    if (hasUnclear) {
                        // æ­£å¸¸æ˜¾ç¤º <?à¤ƒ>
                        span.textContent = "<?" + text + ">";
                    } else {
                        // æ²¡æœ‰unclearå­èŠ‚ç‚¹æ—¶ï¼Œä¿ç•™åŸé€»è¾‘
                        span.textContent = "<" + text + ">";
                    }
                    return span;
                }


                case "unclear": {
                    const span = el("span", "tei-unclear");
                    const text = textContentDeep(node);

                    // console.log("UNCLEAR NODE:", text);  â† è¿™ä¸¤è¡Œæ–°åŠ çš„ï¼Œè°ƒè¯•unclearæ ‡ç­¾åœ¨ç½‘é¡µinspectéƒ¨åˆ†çš„consoleé‡Œdebugç”¨
                    // console.log("FINAL OUTPUT:", `<?${text}>`);  // â† è¿™ä¸¤è¡Œæ–°åŠ çš„ï¼Œä»…ä¸ºdebugè¾“å‡ºç»“æœç”¨

                    if (node.parentNode && node.parentNode.localName === "supplied") {
                        span.textContent = `<?${text}>`;
                    } else {
                        span.textContent = `<${text}>`;
                    }

                    return span;
                }

                case "facsimile":
                case "surface": {
                    const div = el("div", "tei-facsimile");
                    div.appendChild(renderChildren());
                    return div;
                }

                case "graphic": {
                    const img = document.createElement("img");
                    const src = node.getAttribute("url") || node.getAttribute("target");

                    img.src = src;
                    img.alt = "Manuscript image";
                    img.className = "tei-graphic";  // ä¸€å¾‹ç”¨ç¼©ç•¥å›¾æ ·å¼

                    // ç‚¹å‡»ï¼šå…¨å±æ˜¾ç¤ºåŸå›¾
                    img.addEventListener("click", () => {
                        const overlay = document.createElement("div");
                        overlay.className = "tei-image-overlay";

                        const full = document.createElement("img");
                        full.src = src;
                        full.className = "tei-image-full";

                        overlay.appendChild(full);
                        document.body.appendChild(overlay);

                        overlay.addEventListener("click", () => overlay.remove());
                    });

                    return img;
                }


                case "fw": {
                    // running title/page header ä¸åº”è¯¥æ˜¾ç¤ºåœ¨æ­£æ–‡
                    return document.createDocumentFragment();
                }

                case "desc":
                case "sourceDesc": {
                    // ä¸æ˜¾ç¤ºä»»ä½•æ–‡å­—
                    return document.createDocumentFragment(); // å¿½ç•¥æ˜¾ç¤º
                }

                case "listBibl": {
                    const section = el("section", "tei-bibl");
                    section.appendChild(renderChildren());
                    return section;
                }

                case "bibl": {
                    const p = el("p", "tei-bibl-item");

                    // â€”â€” è¯†åˆ« monograph æ ¼å¼ â€”â€”
                    const isMono = node.querySelector("title[level='m']");

                    if (isMono) {
                        const authors = [...node.querySelectorAll("author")]
                            .map(a => a.textContent.trim())
                            .join("ï¼›");

                        const title = node.querySelector("title[level='m']")?.textContent.trim() || "";
                        const pubPlace = node.querySelector("pubPlace")?.textContent.trim() || "";
                        const publisher = node.querySelector("publisher")?.textContent.trim() || "";
                        const date = node.querySelector("date")?.textContent.trim() || "";
                        const pages = node.querySelector("biblScope[unit='page']")?.textContent.trim() || "";

                        // â€”â€” HTML è¾“å‡ºå¥å­ï¼ˆæœ€ç»ˆç½‘é¡µä¼šå‘ˆç°æˆä½ è¦çš„æ ¼å¼ï¼‰ â€”â€”
                        p.textContent =
                            `${authors}ï¼šã€Š${title}ã€‹ï¼Œ${pubPlace}ï¼š${publisher}ï¼Œ${date}å¹´ç‰ˆï¼Œ${pages ? `ç¬¬ ${pages} é ã€‚` : ""}`;

                        return p;
                    }

                    // â€”â€” å…¶ä»–ç±»å‹çš„ biblï¼ˆå¦‚ journal æ–‡ç« ï¼‰ä¿æŒåŸæœ‰é€»è¾‘ â€”â€”

                    p.appendChild(renderChildren());
                    return p;
                }

                case "biblHead":  // â† æ”¹æˆè‡ªå®šä¹‰æ ‡ç­¾åé¿å…å†²çª
                case "headBibl":  // ä»»é€‰ä¸€ä¸ªï¼Œä¸‹é¢ä¸¤è¡ŒåŠ è¯´æ˜
                    const h3 = el("h3");
                    h3.appendChild(renderChildren());
                    return h3;

                case "title": {
                    const level = node.getAttribute("level") || "";
                    const type = node.getAttribute("type") || "";

                    // æœŸåˆŠå / monograph â†’ æ–œä½“
                    if (level === "j" || level === "m") {
                        const em = el("em", "tei-title");
                        em.appendChild(renderChildren()); // âœ… ä¿ç•™å­èŠ‚ç‚¹ï¼ˆå…è®¸åµŒå¥—ï¼‰
                        return em;
                    }

                    // æ–‡ç« æ ‡é¢˜ â†’ åŠ å¼•å·å¹¶ä¿ç•™å­å…ƒç´ 
                    if (level === "a") {
                        const span = el("span", "tei-title-article");
                        span.appendChild(renderChildren()); // âœ… æ”¹æˆ renderChildren()
                        // è‡ªåŠ¨æ·»åŠ å¼•å·
                        const quoted = el("span");
                        quoted.textContent = "â€œ";
                        span.prepend(quoted);
                        const quotedEnd = el("span");
                        quotedEnd.textContent = "â€";
                        span.appendChild(quotedEnd);
                        return span;
                    }

                    // é»˜è®¤æƒ…å†µ
                    const span = el("span", "tei-title");
                    span.appendChild(renderChildren());
                    return span;
                }


                default: {
                    // Unknown TEI element: render its children inline
                    return renderChildren();
                }
            }
        }

        // Utilities
        function el(tag, className) {
            const e = document.createElement(tag);
            if (className) e.className = className;
            return e;
        }
        function textContentDeep(node) {
            let s = "";
            const walker = document.createTreeWalker(node, NodeFilter.SHOW_TEXT, null);
            let n;
            while ((n = walker.nextNode())) s += n.nodeValue;
            return s.trim();
        }

        // Call it with your file name and target container
        // Example: a file at ./sample.xml -> render into #tei-container
        loadTEI("lingyue.xml", "#tei-container");

        const backButton = document.getElementById("legacyBackButton");
        backButton?.addEventListener("click", () => {
            if (window.history.length > 1) {
                window.history.back();
                return;
            }
            window.location.href = "../../transcriptions/";
        });
    </script>

    <style>
        /* Minimal styling */
        .tei-doc {
            line-height: 1.6;
        }

        .tei-note {
            font-size: 0.95em;
            padding-left: 0.8rem;
            border-left: 3px solid #ddd;
            margin: 0.5rem 0;
        }

        .tei-pb {
            opacity: 0.6;
            font-size: 0.9em;
        }

        .tei-div {
            margin: 1rem 0;
        }

        .tei-line {
            margin: 0;
        }

        /* â€”â€” inline æ³¨é‡Šï¼šå’Œæ­£æ–‡åŒä¸€è¡Œï¼Œæ— ç°çº¿ â€”â€” */
        .tei-note-inline {
            color: #7a4e00;
            /* æ³¨é‡Šå­—é¢œè‰²ï¼ˆå¯æ”¹ï¼‰ */
            font-size: 0.9em;
            display: inline;
            cursor: pointer;
            padding: 0 0.15em;
            border-radius: 3px;
        }

        /* è‡ªåŠ¨åŠ ä¸­æ‹¬å· */
        .tei-note-inline::before {
            content: "[";
        }

        .tei-note-inline::after {
            content: "]";
        }

        /* hover é«˜äº®æ˜¾ç¤º tooltip */
        .tei-note-inline:hover {
            color: #a56300;
            background-color: rgba(255, 225, 170, 0.3);
        }

        .tei-node-hit {
            color: #6f4a12;
            background:
                linear-gradient(180deg,
                    rgba(255, 236, 189, 0) 46%,
                    rgba(255, 221, 156, 0.58) 46%,
                    rgba(255, 221, 156, 0.58) 100%);
            border-radius: 0.2em;
            padding: 0 0.08em;
            transition: color 0.2s ease, background-color 0.2s ease;
        }

        .tei-node-hit:hover {
            color: #8a5a1a;
            background-color: rgba(255, 225, 170, 0.34);
        }

        .node-hit-badge {
            margin-top: 0.8rem;
            margin-bottom: 0.5rem;
            font-size: 0.84rem;
            color: #5a4a36;
            background: rgba(242, 233, 218, 0.9);
            border: 1px solid rgba(122, 96, 68, 0.25);
            border-radius: 6px;
            padding: 0.35rem 0.55rem;
            display: inline-block;
        }

        .node-hit-details {
            margin: 0.25rem 0 0.8rem;
            font-size: 0.82rem;
            color: #4b3d2d;
        }

        .node-hit-details summary {
            cursor: pointer;
            font-weight: 600;
            margin-bottom: 0.35rem;
        }

        .node-hit-details ul {
            margin: 0;
            padding-left: 1.1rem;
            columns: 2;
            column-gap: 1.2rem;
        }

        .node-hit-details li {
            list-style: disc;
            background: transparent;
            box-shadow: none;
            padding: 0;
            margin: 0 0 0.2rem 0;
            border-radius: 0;
            break-inside: avoid;
        }

        .node-hit-details code {
            background: rgba(255, 243, 219, 0.65);
            border-radius: 4px;
            padding: 0.02rem 0.24rem;
            font-size: 0.78rem;
        }

        .node-hit-details span {
            color: #7a654a;
            margin-left: 0.25rem;
        }


        /* â€”â€” block æ³¨é‡Šï¼ˆè„šæ³¨ï¼‰ä¾ç„¶ä¿æŒç«–çº¿ â€”â€” */
        .tei-note {
            font-size: 0.95em;
            padding-left: 0.8rem;
            border-left: 3px solid #ddd;
            /* ç°ç«–çº¿ä¿ç•™ */
            margin: 0.5rem 0;
        }

        /* è®©è„šæ³¨ç‹¬ç«‹æ¢è¡Œ */
        .tei-note-block {
            display: block;
            margin: 0.5em 0;
        }

        /* Override default graphic style: show as thumbnail */
        .tei-graphic {
            max-width: 180px;
            /* é»˜è®¤ç¼©ç•¥å›¾å®½åº¦ */
            height: auto;
            display: block;
            margin: 1.2em auto;
            border-radius: 6px;
            cursor: zoom-in;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
        }

        /* ç‚¹å‡»åæ”¾å¤§çš„èƒŒæ™¯ */
        .tei-image-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.75);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 99999;
            cursor: zoom-out;
        }

        /* æ”¾å¤§çš„å¤§å›¾ */
        .tei-image-full {
            max-width: 90%;
            max-height: 90%;
            border-radius: 8px;
            box-shadow: 0 0 12px rgba(255, 255, 255, 0.8);
        }

        .tei-bibl {
            margin-top: 2em;
            padding-top: 1.1em;
            position: relative;
        }

        .tei-bibl::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(90, 74, 56, 0.4), transparent);
        }

        .tei-bibl-item {
            margin-left: 1em;
            line-height: 1.6;
        }

        .tei-title {
            font-style: italic;
        }

        .tei-title-article {
            font-style: normal;
        }
    </style>

</body>

</html>
