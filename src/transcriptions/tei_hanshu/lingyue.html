<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../../css/style.css" />
    <style>
        :root {
            --hanshu-main-span: 760px;
            --hanshu-side-panel-gap: 14px;
            --hanshu-side-panel-width: clamp(300px, 26vw, 620px);
            --transcription-mini-heading-size: 1.4rem;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: Georgia, 'Times New Roman', serif;
            background-color: #f8f5f2;
            color: #333;
            line-height: 1.6;
        }

        .tei-page {
            max-width: 700px;
            margin: auto;
            padding: 3em 1.5em;
            position: relative;
        }

        h1 {
            font-size: 2em;
            margin-bottom: 1em;
            padding-bottom: 0.3em;
            border-bottom: none;
            position: relative;
        }

        h1::after {
            content: "";
            display: block;
            margin-top: 0.5rem;
            width: 100%;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(90, 74, 56, 0.4), transparent);
        }

        .tei-head-with-script {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.86rem;
            margin: 0.12rem 0 0.48rem;
        }

        .tei-head-with-script h2 {
            margin: 0;
        }

        .tei-doc h2,
        .tei-doc h3,
        .tei-bibl h2,
        .tei-bibl h3 {
            text-transform: uppercase;
            letter-spacing: 0.2em;
            font-size: var(--transcription-mini-heading-size);
            font-weight: 700;
            color: #4c4034;
            line-height: 1.2;
        }

        .script-toggle-button {
            border: none;
            border-radius: 8px;
            padding: 0.42rem 0.78rem;
            width: 9.2rem;
            background: #ebe1cf;
            color: #4a3e30;
            font-family: Georgia, serif;
            cursor: pointer;
            box-shadow: 0 2px 0 rgba(74, 62, 48, 0.18);
            transition: background-color 0.18s ease, transform 0.12s ease;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            white-space: nowrap;
            margin-left: auto;
        }

        .script-toggle-button:hover {
            background: #e6d9c4;
        }

        .script-toggle-button:active {
            transform: translateY(1px);
        }

        p {
            margin-bottom: 2em;
        }

        a {
            text-decoration: none;
            color: #0066cc;
            font-weight: bold;
            transition: color 0.3s ease;
        }

        a:hover {
            color: #004499;
        }

        ul {
            list-style: none;
            padding: 0;
        }

        li {
            background: #fff;
            padding: 1em;
            margin-bottom: 1em;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.06);
            transition: transform 0.2s ease;
        }

        li:hover {
            transform: translateY(-2px);
        }

        .no-link {
            color: #aaa;
            text-decoration: line-through;
            cursor: not-allowed;
            font-style: italic;
        }

        /* New CSS for the home icon */
        .home-link {
            position: absolute;
            top: 1em;
            left: -100px;
            /* Move it outside the left margin */
        }

        .home-link img {
            width: 88px;
            height: auto;
            border-radius: 4px;
            cursor: pointer;
            background-color: #fff;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
        }

        .home-link img:hover {
            box-shadow: 0 0 8px rgba(0, 0, 0, 0.3);
        }

        .legacy-back {
            margin: 0 0 1.2rem;
        }

        .legacy-back-button {
            border: none;
            border-radius: 8px;
            padding: 0.45rem 0.8rem;
            background: #f6efe5;
            color: #4a3e30;
            font-family: Georgia, serif;
            cursor: pointer;
            box-shadow: 0 3px 0 rgba(74, 62, 48, 0.22);
            transition: transform 0.15s ease, box-shadow 0.15s ease, background-color 0.2s ease;
        }

        .legacy-back-button:hover {
            background: #f3ece2;
        }

        .legacy-back-button:active {
            transform: translateY(1px);
            box-shadow: 0 1px 0 rgba(74, 62, 48, 0.22);
        }

        .xml-link-block {
            margin-top: 1.6rem;
            font-size: 0.88rem;
            color: #5a4d3d;
            display: inline-block;
        }

        .xml-link-block a {
            font-size: 0.88rem;
            color: #4b3a23;
            text-decoration: none;
            font-weight: 600;
        }

        .xml-link-block a:hover {
            text-decoration: underline;
        }

        .xml-link-block::after {
            content: "";
            display: block;
            margin-top: 0.45rem;
            width: 70%;
            height: 1px;
            background: linear-gradient(90deg, rgba(90, 74, 56, 0.6), transparent);
        }

        .line-interaction-hint {
            display: block;
            font-size: 0.84rem;
            color: #6c5a46;
            line-height: 1.35;
            margin: 1.15rem 0 0.9rem;
        }
    </style>
</head>

<body>
    <header class="site-header">
        <div class="logo-container">
            <img src="../../assets/logo.png" class="logo-icon" width="50" height="50" loading="eager" decoding="async"
                alt="MATHesis logo" />
            <img src="../../assets/logotype.svg" class="letter-logo" width="140" height="32" loading="eager"
                decoding="async" alt="MATHesis" />
        </div>
        <nav class="site-nav">
            <a href="../../">Home</a>
            <a href="../../search/">Search</a>
            <a href="../../transcriptions/">Transcriptions</a>
            <a href="../../visualization/">Visualization</a>
            <a href="../../map/">Map</a>
            <a href="../../about/">About</a>
        </nav>
    </header>

    <main class="tei-page">
        <div class="legacy-back">
            <button id="legacyBackButton" class="legacy-back-button" type="button">Back</button>
        </div>
        <button id="scriptToggleButtonHanshu" class="script-toggle-button" type="button" data-script-mode="traditional" hidden>
            Script: Traditional
        </button>
        <div id="tei-container"></div>
        <span id="lineInteractionHintHanshu" class="line-interaction-hint">Tip: single-click a highlighted matched node for details; double-click a matched node to query CText.</span>
        <div class="xml-link-block">
            <a href="./lingyue.xml" target="_blank" rel="noopener">view XML</a>
        </div>
    </main>
    <script type="module">
        import { bindNodeHitPopup, resolveNodeByTerm } from "../../js/nodeEntryPopup.js";

        let nodeRecordsCache = null;
        let hanshuScriptMode = "traditional";

        async function loadTEI(fileName, targetSelector) {
            const target = document.querySelector(targetSelector);
            if (!target) throw new Error("Target element not found: " + targetSelector);

            try {
                const res = await fetch(`./${fileName}`, { headers: { "Accept": "application/xml" } });
                if (!res.ok) throw new Error(`HTTP ${res.status} for ${fileName}`);
                const xmlText = await res.text();

                // Parse XML (TEI usually uses a default namespace)
                // Parse XML and strip namespace manually to preserve all TEI tags
                const parser = new DOMParser();
                let xmlTextNoNS = xmlText.replace(/xmlns="[^"]+"/, "");  // üëà ÂéªÊéâÈªòËÆ§ namespace
                const xml = parser.parseFromString(xmlTextNoNS, "text/xml");


                // Basic parse error check
                if (xml.getElementsByTagName("parsererror").length) {
                    throw new Error("XML parse error");
                }

                // Render TEI ‚Üí HTML
                const html = teiNodeToHTML(xml.documentElement);
                target.innerHTML = "";
                target.appendChild(html);
                placeHanshuScriptButton(target);
                await applyHanshuScriptMode(hanshuScriptMode);
                placeHanshuLineInteractionHint(target);
                await runNodeHighlightPrototype(target, fileName);
            } catch (err) {
                console.error(err);
                // Fallback: show raw XML safely
                target.textContent = "Failed to render TEI. Showing raw XML:\n\n" + (err?.message || "");
                try {
                    const res2 = await fetch(`./${fileName}`);
                    const raw = await res2.text();
                    target.textContent += "\n\n" + raw;
                } catch { }
            }
        }

        async function runNodeHighlightPrototype(container, sourceFileName) {
            try {
                const terms = await loadNodeTermsForPrototype();
                clearHanshuNodeHighlights(container);
                const stats = highlightNodeTerms(container, terms);
                renderHitSummary(stats);
                bindHanshuNodePopup(container);
                initCtextLookupForNodeHits(container);
                bindHanshuCentralDismiss(container);
                console.log(`[Node highlight prototype] file=${sourceFileName} totalHits=${stats.totalHits} matchedTerms=${stats.matchedTerms} dictionarySize=${terms.length}`);
                if (stats.topHits.length) console.table(stats.topHits);
            } catch (err) {
                console.warn("[Node highlight prototype] failed:", err);
                renderHitSummary({ totalHits: 0, matchedTerms: 0, dictionarySize: 0, failed: true, topHits: [] });
            }
        }

        function clearHanshuNodeHighlights(container) {
            container.querySelectorAll(".tei-node-hit").forEach((mark) => {
                const text = document.createTextNode(mark.textContent || "");
                mark.replaceWith(text);
            });
        }

        async function loadNodeTermsForPrototype() {
            const path = window.location.pathname || "";
            const basePrefix = path.includes("/transcriptions/") ? path.split("/transcriptions/")[0] : "";
            const dataUrl = `${basePrefix}/data.json`;
            const mapUrl = `${basePrefix}/simp_to_trad_map.json`;
            const res = await fetch(dataUrl, { headers: { "Accept": "application/json" } });
            if (!res.ok) throw new Error(`HTTP ${res.status} for ${dataUrl}`);
            const data = await res.json();
            const nodes = Array.isArray(data?.nodes) ? data.nodes : [];
            nodeRecordsCache = nodes;

            const terms = new Set();
            const splitRegex = /[\s,/;:()[\]{}|]+/;
            const zhNumerals = new Set(["‰∏Ä", "‰∫å", "‰∏â", "Âõõ", "‰∫î", "ÂÖ≠", "‰∏É", "ÂÖ´", "‰πù", "ÂçÅ"]);
            const arabicToZhNumeral = {
                "1": "‰∏Ä",
                "2": "‰∫å",
                "3": "‰∏â",
                "4": "Âõõ",
                "5": "‰∫î",
                "6": "ÂÖ≠",
                "7": "‰∏É",
                "8": "ÂÖ´",
                "9": "‰πù",
                "10": "ÂçÅ"
            };

            let simpToTrad = {};
            try {
                const mapRes = await fetch(mapUrl, { headers: { "Accept": "application/json" } });
                if (mapRes.ok) {
                    simpToTrad = await mapRes.json();
                }
            } catch {
                simpToTrad = {};
            }
            const tradToSimp = Object.fromEntries(Object.entries(simpToTrad).map(([simp, trad]) => [trad, simp]));
            window.__ctextTradToSimpMap = tradToSimp;

            const toSimp = (s) => Array.from(s).map(ch => tradToSimp[ch] || ch).join("");
            const toTrad = (s) => Array.from(s).map(ch => simpToTrad[ch] || ch).join("");
            const addWithVariants = (term) => {
                terms.add(term);

                const simpTerm = toSimp(term);
                const tradTerm = toTrad(term);
                if (simpTerm) terms.add(simpTerm);
                if (tradTerm) terms.add(tradTerm);

                // Generate limited mixed variants to catch hybrid forms like "ÈªÑÈêò".
                const chars = Array.from(term);
                const options = chars.map(ch => {
                    const opts = new Set([ch, tradToSimp[ch] || ch, simpToTrad[ch] || ch]);
                    return Array.from(opts);
                });
                const convertibleCount = options.filter(opts => opts.length > 1).length;
                if (chars.length > 6 || convertibleCount > 4) return;

                const build = (i, acc) => {
                    if (i === options.length) {
                        terms.add(acc);
                        return;
                    }
                    for (const ch of options[i]) {
                        build(i + 1, acc + ch);
                    }
                };
                build(0, "");
            };

            const add = (raw) => {
                if (typeof raw !== "string") return;
                const term = raw.trim().replace(/\s+/g, " ");
                if (!term) return;
                if (/^\d+$/.test(term)) {
                    // Never match Arabic numerals directly, but map 1-10 to Chinese numerals.
                    const mapped = arabicToZhNumeral[term];
                    if (mapped) addWithVariants(mapped);
                    return;
                }

                const hasCJK = /[\u3400-\u9fff]/u.test(term);
                if (hasCJK && term.length < 2 && !zhNumerals.has(term)) return;
                if (!hasCJK && term.length < 3) return;
                addWithVariants(term);

                // Prototype-only fuzzy aliases so we can see visible hits quickly.
                if (hasCJK && term.length >= 3) {
                    addWithVariants(term.slice(0, 2));
                    addWithVariants(term.slice(0, 3));
                }
            };

            for (const node of nodes) {
                const p = node?.properties || node || {};
                const candidates = [p.name, p.name_zh, p.name_zh_simple, p.name_en, p.name_sa, p.transliteration];
                for (const value of candidates) {
                    add(value);
                    if (typeof value === "string" && splitRegex.test(value)) {
                        value.split(splitRegex).forEach(add);
                    }
                }
            }

            return Array.from(terms).sort((a, b) => b.length - a.length).slice(0, 2000);
        }

        async function loadNodeRecords() {
            if (Array.isArray(nodeRecordsCache)) return nodeRecordsCache;
            const path = window.location.pathname || "";
            const basePrefix = path.includes("/transcriptions/") ? path.split("/transcriptions/")[0] : "";
            const dataUrl = `${basePrefix}/data.json`;
            const res = await fetch(dataUrl, { headers: { "Accept": "application/json" } });
            if (!res.ok) throw new Error(`HTTP ${res.status} for ${dataUrl}`);
            const data = await res.json();
            nodeRecordsCache = Array.isArray(data?.nodes) ? data.nodes : [];
            return nodeRecordsCache;
        }

        function normalizeNodeLookupTerm(value) {
            const raw = String(value || "").trim();
            if (!raw) return "";
            if (/[\u3400-\u9fff]/u.test(raw)) {
                return normalizeLookupKey(raw);
            }
            return raw.toLowerCase().replace(/\s+/g, " ");
        }

        function bindHanshuNodePopup(root) {
            bindNodeHitPopup({
                root,
                panelId: "hanshuNodePanel",
                panelTitle: "Node Details",
                emptyText: "Single-click a highlighted matched node to view details.",
                panelPosition: {
                    left: "14px",
                    top: "88px"
                },
                deferSingleClickMs: 220,
                valueFilter: ({ key }) => key !== "value",
                resolveNode: async ({ term }) => {
                    const nodes = await loadNodeRecords();
                    const resolved = resolveNodeByTerm(nodes, term, {
                        normalizer: normalizeNodeLookupTerm
                    });
                    if (resolved) return resolved;
                    const fallback = normalizeLookupKey(term) || term;
                    return resolveNodeByTerm(nodes, fallback, {
                        normalizer: normalizeNodeLookupTerm
                    });
                }
            });
        }

        function escapeRegex(s) {
            return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        }

        function highlightNodeTerms(container, terms) {
            if (!terms.length) return { totalHits: 0, matchedTerms: 0, matchedGroups: 0, topHits: [], groupedTerms: [], dictionarySize: 0 };
            const regex = new RegExp(terms.map(escapeRegex).join("|"), "gu");
            const counts = new Map();
            const groupedCounts = new Map();
            let totalHits = 0;

            const walker = document.createTreeWalker(
                container,
                NodeFilter.SHOW_TEXT,
                {
                    acceptNode(node) {
                        if (!node.nodeValue || !node.nodeValue.trim()) return NodeFilter.FILTER_REJECT;
                        const parent = node.parentElement;
                        if (!parent) return NodeFilter.FILTER_REJECT;
                        if (parent.closest("h1")) return NodeFilter.FILTER_REJECT;
                        if (parent.closest("[hidden]")) return NodeFilter.FILTER_REJECT;
                        if (parent.closest("script, style, a, button, code, pre, .tei-node-hit")) return NodeFilter.FILTER_REJECT;
                        return NodeFilter.FILTER_ACCEPT;
                    }
                }
            );

            const targets = [];
            let n;
            while ((n = walker.nextNode())) targets.push(n);

            for (const textNode of targets) {
                const text = textNode.nodeValue;
                regex.lastIndex = 0;
                if (!regex.test(text)) continue;
                regex.lastIndex = 0;

                const frag = document.createDocumentFragment();
                let cursor = 0;
                for (const m of text.matchAll(regex)) {
                    const term = m[0];
                    const start = m.index || 0;
                    const end = start + term.length;

                    if (start > cursor) frag.appendChild(document.createTextNode(text.slice(cursor, start)));
                    const mark = document.createElement("span");
                    mark.className = "tei-node-hit";
                    mark.textContent = term;
                    const queryKey = normalizeLookupKey(term) || term;
                    mark.dataset.queryKey = queryKey;
                    frag.appendChild(mark);

                    counts.set(term, (counts.get(term) || 0) + 1);
                    const bucket = groupedCounts.get(queryKey) || { total: 0, forms: new Map() };
                    bucket.total += 1;
                    bucket.forms.set(term, (bucket.forms.get(term) || 0) + 1);
                    groupedCounts.set(queryKey, bucket);
                    totalHits += 1;
                    cursor = end;
                }
                if (cursor < text.length) frag.appendChild(document.createTextNode(text.slice(cursor)));
                textNode.parentNode.replaceChild(frag, textNode);
            }

            const topHits = Array.from(counts.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 20)
                .map(([term, hits]) => ({ term, hits }));

            const groupedTerms = Array.from(groupedCounts.entries())
                .map(([queryKey, bucket]) => {
                    const forms = Array.from(bucket.forms.entries())
                        .sort((a, b) => b[1] - a[1] || b[0].length - a[0].length)
                        .map(([term, hits]) => ({ term, hits }));
                    return {
                        queryKey,
                        total: bucket.total,
                        forms
                    };
                })
                .sort((a, b) => b.total - a.total || (b.forms[0]?.term?.length || 0) - (a.forms[0]?.term?.length || 0))
                .slice(0, 30);

            return {
                totalHits,
                matchedTerms: counts.size,
                matchedGroups: groupedCounts.size,
                topHits,
                groupedTerms,
                dictionarySize: terms.length
            };
        }

        function renderHitSummary(stats) {
            const container = document.querySelector(".xml-link-block") || document.body;
            let block = document.getElementById("nodeHitSummary");
            if (!block) {
                block = document.createElement("section");
                block.id = "nodeHitSummary";
                block.className = "node-hit-summary";
                container.insertAdjacentElement("beforebegin", block);
            }
            if (stats.failed) {
                block.textContent = "Node highlight: failed";
                return;
            }
            const items = (stats.groupedTerms || [])
                .map(({ total, forms }) => {
                    const primary = forms?.[0]?.term || "‚Äî";
                    const variants = (forms || [])
                        .slice(1, 4)
                        .map((f) => `${f.term} ${f.hits}`)
                        .join(" / ");
                    const variantsHtml = variants ? `<span class="node-hit-variants">${escapeHtml(variants)}</span>` : "";
                    return `<li><code>${escapeHtml(primary)}</code> <span>${total}</span>${variantsHtml}</li>`;
                })
                .join("");

            block.innerHTML = `
                <div class="node-hit-head">
                    <button id="toggleNodeHitPanel" class="node-hit-toggle-btn" type="button" aria-expanded="false">
                        Matched terms
                    </button>
                </div>
                <section id="nodeHitPanel" class="node-hit-panel">
                    <details class="node-hit-details" open>
                        <summary>Grouped terms (top 30) ¬∑ ${stats.matchedGroups ?? stats.matchedTerms} groups / ${stats.totalHits} hits</summary>
                        <ul>${items || "<li><em>No matches</em></li>"}</ul>
                    </details>
                </section>
            `;

            const toggle = document.getElementById("toggleNodeHitPanel");
            const panel = document.getElementById("nodeHitPanel");
            toggle?.addEventListener("click", () => {
                if (!panel) return;
                const opened = panel.classList.toggle("is-open");
                toggle.setAttribute("aria-expanded", opened ? "true" : "false");
            });
        }

        function bindHanshuCentralDismiss(container) {
            if (!container || container.dataset.hanshuDismissReady === "1") return;
            container.dataset.hanshuDismissReady = "1";

            container.addEventListener("click", (event) => {
                const target = event.target;
                if (!(target instanceof Element)) return;
                if (!container.contains(target)) return;
                if (target.closest(".tei-node-hit, a, button, summary, details, .node-hit-summary")) return;

                const nodePanel = document.getElementById("hanshuNodePanel");
                if (nodePanel instanceof HTMLElement) nodePanel.classList.remove("is-open");
                const ctextPanel = document.getElementById("ctextResultPanel");
                if (ctextPanel instanceof HTMLElement) ctextPanel.classList.remove("is-open");
            });
        }

        async function applyHanshuScriptMode(mode) {
            hanshuScriptMode = mode === "simplified" ? "simplified" : "traditional";
            const root = document.getElementById("tei-container");
            const trad = root?.querySelector?.(".tei-transcription-primary");
            const simp = root?.querySelector?.(".tei-transcription-simplified");
            if (trad instanceof HTMLElement) trad.hidden = hanshuScriptMode !== "traditional";
            if (simp instanceof HTMLElement) simp.hidden = hanshuScriptMode !== "simplified";

            const button = document.getElementById("scriptToggleButtonHanshu");
            if (!(button instanceof HTMLElement)) return;
            button.dataset.scriptMode = hanshuScriptMode;
            button.textContent = hanshuScriptMode === "simplified" ? "Script: Simplified" : "Script: Traditional";
        }

        function escapeHtml(s) {
            return String(s || "")
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#39;");
        }

        function buildQueryVariants(term) {
            const text = (term || "").trim();
            if (!text) return [];
            const stop = new Set(["‰πã", "ÂÖ∂", "ËÄå", "‰ª•", "‰∫é", "Êñº", "‰πü", "ËÄÖ", "ÁÑâ", "‰πé", "Áü£", "Êõ∞", "‰∫ë"]);
            const chars = Array.from(text);
            const out = new Set([text]);
            for (let i = 0; i < chars.length - 1; i += 1) out.add(chars.slice(i, i + 2).join(""));
            chars.forEach(ch => { if (!stop.has(ch) && ch.trim()) out.add(ch); });
            return Array.from(out).sort((a, b) => b.length - a.length).slice(0, 12);
        }

        function normalizeLookupKey(input) {
            const text = String(input || "").trim().replace(/\s+/g, "");
            if (!text) return "";
            const tradToSimp = window.__ctextTradToSimpMap || {};
            return Array.from(text).map(ch => tradToSimp[ch] || ch).join("");
        }

        const ctextResultCache = new Map();
        const ctextInFlightCache = new Map();

        function openCtextPanelWithEnterAnimation(panel) {
            if (!(panel instanceof HTMLElement)) return;
            if (panel.classList.contains("is-open")) return;
            requestAnimationFrame(() => {
                panel.classList.add("is-open");
            });
        }

        function makeCtextPanelResizable(panel) {
            if (!(panel instanceof HTMLElement)) return;
            if (panel.dataset.resizeBound === "1") return;
            const handle = panel.querySelector(".ctext-resize-handle");
            if (!(handle instanceof HTMLElement)) return;
            panel.dataset.resizeBound = "1";

            let resizing = false;
            let startX = 0;
            let startWidth = 0;

            const clampWidth = (value) => {
                const maxWidth = Math.max(300, window.innerWidth * 0.46);
                return Math.min(Math.max(value, 280), maxWidth);
            };

            const onMove = (event) => {
                if (!resizing) return;
                const side = panel.classList.contains("side-left") ? "left" : "right";
                const dx = event.clientX - startX;
                const nextWidth = side === "left" ? startWidth + dx : startWidth - dx;
                panel.style.width = `${clampWidth(nextWidth)}px`;
            };

            const stop = () => {
                if (!resizing) return;
                resizing = false;
                panel.classList.remove("is-resizing");
                window.removeEventListener("pointermove", onMove);
                window.removeEventListener("pointerup", stop);
            };

            handle.addEventListener("pointerdown", (event) => {
                if (event.button !== 0) return;
                event.preventDefault();
                resizing = true;
                startX = event.clientX;
                startWidth = panel.getBoundingClientRect().width;
                panel.classList.add("is-resizing");
                window.addEventListener("pointermove", onMove);
                window.addEventListener("pointerup", stop);
            });
        }

        function ensureCtextResultPanel() {
            let panel = document.getElementById("ctextResultPanel");
            if (panel) return panel;

            const I18N = {
                zh: {
                    title: "CText Ê£ÄÁ¥¢",
                    empty: "ÂèåÂáªÊ≠£ÊñáÈáåÈ´ò‰∫ÆËØçÊù°ÔºåÂú®Âè≥‰æßÊü•ÁúãÂ§ñÈÉ®Ê£ÄÁ¥¢ÁªìÊûú„ÄÇ",
                    query: "ËØçÊù°Ôºö",
                    loading: "Ê£ÄÁ¥¢‰∏≠ÔºàÂêéÁ´ØÂàÜËØçÂèò‰ΩìÈ°∫Â∫èÊü•ËØ¢Ôºâ...",
                    error: "ÂêéÁ´ØÊ£ÄÁ¥¢ÊöÇ‰∏çÂèØÁî®Ôºö",
                    hint: "ÂèØÂÖàÊâãÂä®ÊâìÂºÄ‰ª•‰∏ãÊü•ËØ¢Ôºö",
                    variantSearch: "Âèò‰ΩìÊ£ÄÁ¥¢",
                    variantTerm: "Ê£ÄÁ¥¢ËØçÔºö",
                    scope: "Ê£ÄÁ¥¢ËåÉÂõ¥Ôºö",
                    type: "Ê£ÄÁ¥¢Á±ªÂûãÔºö",
                    condition: "Êù°‰ª∂1Ôºö",
                    matched: "Á¨¶ÂêàÊ¨°Êï∞Ôºö",
                    textLabel: "ÊñáÊú¨ÂêçÔºö",
                    noResult: "Êú™ËøîÂõûÂèØËß£ÊûêÁªìÊûú„ÄÇ"
                },
                en: {
                    title: "CText Search",
                    empty: "Double-click a highlighted term to view external lookup results.",
                    query: "Query: ",
                    loading: "Searching (backend variant pipeline)...",
                    error: "Backend lookup unavailable: ",
                    hint: "You can open these queries manually:",
                    variantSearch: "Variant search",
                    variantTerm: "Lookup term: ",
                    scope: "Scope: ",
                    type: "Request type: ",
                    condition: "Condition 1: ",
                    matched: "Matched: ",
                    textLabel: "Texts: ",
                    noResult: "No parsable result returned."
                }
            };
            const t = (k) => (I18N[window.__ctextLang || "zh"] || I18N.zh)[k] || k;
            window.__ctextLang = window.__ctextLang || "zh";
            window.__ctextPanelState = window.__ctextPanelState || { mode: "empty", term: "", payload: null, err: "" };

            panel = document.createElement("aside");
            panel.id = "ctextResultPanel";
            panel.className = "ctext-result-panel side-right";
            panel.innerHTML = `
                <div class="ctext-panel-head">
                    <div class="ctext-panel-title">${t("title")}</div>
                    <div class="ctext-lang-switch" role="group" aria-label="CText language switch">
                        <button type="button" class="ctext-lang-btn is-active" data-lang="zh">‰∏≠Êñá</button>
                        <button type="button" class="ctext-lang-btn" data-lang="en">EN</button>
                    </div>
                    <button class="ctext-close-btn" id="ctextCloseBtn" type="button">√ó</button>
                </div>
                <div class="ctext-panel-body" id="ctextPanelBody">
                    <p class="ctext-empty">${t("empty")}</p>
                </div>
                <div class="ctext-resize-handle" aria-hidden="true"></div>
            `;
            document.body.appendChild(panel);
            makeCtextPanelResizable(panel);

            const closeBtn = panel.querySelector("#ctextCloseBtn");
            closeBtn?.addEventListener("click", () => panel.classList.remove("is-open"));
            const syncLangButtons = () => {
                panel.querySelectorAll(".ctext-lang-btn").forEach(btn => {
                    btn.classList.toggle("is-active", btn.dataset.lang === window.__ctextLang);
                });
                const titleEl = panel.querySelector(".ctext-panel-title");
                if (titleEl) titleEl.textContent = t("title");
            };
            const rerender = () => {
                const state = window.__ctextPanelState || { mode: "empty" };
                if (state.mode === "loading") {
                    renderCtextLoading(state.term || "", true);
                } else if (state.mode === "error") {
                    renderCtextError(state.term || "", state.err || "", true);
                } else if (state.mode === "results") {
                    renderCtextResults(state.term || "", state.payload || {}, true);
                } else {
                    const body = panel.querySelector("#ctextPanelBody");
                    if (body) body.innerHTML = `<p class="ctext-empty">${t("empty")}</p>`;
                }
                syncLangButtons();
            };
            panel.querySelectorAll(".ctext-lang-btn").forEach(btn => {
                btn.addEventListener("click", () => {
                    const lang = btn.dataset.lang === "en" ? "en" : "zh";
                    if (window.__ctextLang === lang) return;
                    window.__ctextLang = lang;
                    rerender();
                });
            });
            syncLangButtons();
            return panel;
        }

        function renderCtextLoading(term, fromRerender = false) {
            const panel = ensureCtextResultPanel();
            const lang = window.__ctextLang || "zh";
            const t = {
                query: lang === "en" ? "Query: " : "ËØçÊù°Ôºö",
                loading: lang === "en" ? "Searching (backend variant pipeline)..." : "Ê£ÄÁ¥¢‰∏≠ÔºàÂêéÁ´ØÂàÜËØçÂèò‰ΩìÈ°∫Â∫èÊü•ËØ¢Ôºâ..."
            };
            if (!fromRerender) window.__ctextPanelState = { mode: "loading", term, payload: null, err: "" };
            const body = panel.querySelector("#ctextPanelBody");
            openCtextPanelWithEnterAnimation(panel);
            body.innerHTML = `
                <p class="ctext-query"><strong>${t.query}</strong>${escapeHtml(term)}</p>
                <p class="ctext-loading">${t.loading}</p>
            `;
        }

        function renderCtextError(term, errMsg, fromRerender = false) {
            const panel = ensureCtextResultPanel();
            const lang = window.__ctextLang || "zh";
            const t = {
                query: lang === "en" ? "Query: " : "ËØçÊù°Ôºö",
                error: lang === "en" ? "Backend lookup unavailable: " : "ÂêéÁ´ØÊ£ÄÁ¥¢ÊöÇ‰∏çÂèØÁî®Ôºö",
                hint: lang === "en" ? "You can open these queries manually:" : "ÂèØÂÖàÊâãÂä®ÊâìÂºÄ‰ª•‰∏ãÊü•ËØ¢Ôºö"
            };
            if (!fromRerender) window.__ctextPanelState = { mode: "error", term, payload: null, err: errMsg || "" };
            const body = panel.querySelector("#ctextPanelBody");
            const variants = buildQueryVariants(term);
            const links = variants.map(v =>
                `<li><a target="_blank" rel="noopener" href="https://ctext.org/mathematics/zh?if=gb&searchu=${encodeURIComponent(v)}">${escapeHtml(v)}</a></li>`
            ).join("");
            body.innerHTML = `
                <p class="ctext-query"><strong>${t.query}</strong>${escapeHtml(term)}</p>
                <p class="ctext-error">${t.error}${escapeHtml(errMsg || "unknown error")}</p>
                <p class="ctext-hint">${t.hint}</p>
                <ul class="ctext-fallback-links">${links}</ul>
            `;
            openCtextPanelWithEnterAnimation(panel);
        }

        function renderCtextResults(term, payload, fromRerender = false) {
            const panel = ensureCtextResultPanel();
            const lang = window.__ctextLang || "zh";
            const t = {
                query: lang === "en" ? "Query: " : "ËØçÊù°Ôºö",
                variantSearch: lang === "en" ? "Variant search" : "Âèò‰ΩìÊ£ÄÁ¥¢",
                variantTerm: lang === "en" ? "Lookup term: " : "Ê£ÄÁ¥¢ËØçÔºö",
                scope: lang === "en" ? "Scope: " : "Ê£ÄÁ¥¢ËåÉÂõ¥Ôºö",
                type: lang === "en" ? "Request type: " : "Ê£ÄÁ¥¢Á±ªÂûãÔºö",
                condition: lang === "en" ? "Condition 1: " : "Êù°‰ª∂1Ôºö",
                matched: lang === "en" ? "Matched: " : "Á¨¶ÂêàÊ¨°Êï∞Ôºö",
                textLabel: lang === "en" ? "Texts: " : "ÊñáÊú¨ÂêçÔºö",
                noResult: lang === "en" ? "No parsable result returned." : "Êú™ËøîÂõûÂèØËß£ÊûêÁªìÊûú„ÄÇ"
            };
            const scopeToDisplay = (scope) => {
                if (lang !== "en") return scope;
                const s = String(scope || "").trim();
                if (/^(ÁÆóÊõ∏|ÁÆó‰π¶)$/u.test(s)) return "Mathematics";
                return s;
            };
            const typeToDisplay = (type) => {
                if (lang !== "en") return type;
                const s = String(type || "").trim();
                if (/^ÊÆµËêΩ$/u.test(s)) return "Paragraph";
                return s;
            };
            const conditionToDisplay = (condition) => {
                if (lang !== "en") return condition;
                const s = String(condition || "").trim();
                const m = s.match(/^ÂåÖÂê´Â≠óË©û\s*["‚Äú](.+?)["‚Äù]$/u) || s.match(/^ÂåÖÂê´Â≠óËØç\s*["‚Äú](.+?)["‚Äù]$/u);
                if (m) return `Contains text "${m[1]}"`;
                return s;
            };
            if (!fromRerender) window.__ctextPanelState = { mode: "results", term, payload, err: "" };
            const body = panel.querySelector("#ctextPanelBody");
            const searchesRaw = Array.isArray(payload?.searches) ? payload.searches : [];
            const searches = searchesRaw
                .map((item, idx) => ({ item, idx }))
                .sort((a, b) => {
                    const an = (typeof a.item?.hitCount === "number" && Number.isFinite(a.item.hitCount)) ? a.item.hitCount : -1;
                    const bn = (typeof b.item?.hitCount === "number" && Number.isFinite(b.item.hitCount)) ? b.item.hitCount : -1;
                    if (bn !== an) return bn - an;
                    return a.idx - b.idx;
                })
                .map(x => x.item);
            const ctextDebug = new URLSearchParams(window.location.search).get("ctextDebug") === "1";

            const blocks = searches.map(item => {
                const hasNumericHit = typeof item?.hitCount === "number" && Number.isFinite(item.hitCount);
                const hitCountDisplay = hasNumericHit ? String(item.hitCount) : "‚Äî";
                const scopeClean = String(item?.scope || "‚Äî").replace(/[¬∑‚Ä¢,Ôºå.„ÄÇ;Ôºõ:Ôºö\s]+$/g, "");
                const scopeDisplay = scopeToDisplay(scopeClean || "‚Äî");
                const typeDisplay = typeToDisplay(item.searchType || "");
                const conditionDisplay = conditionToDisplay(item.condition || "‚Äî");
                const textGroupsRaw = Array.isArray(item?.structured?.textGroups) ? item.structured.textGroups : [];
                const textGroups = textGroupsRaw;
                const renderCount = (count, countUrl) => {
                    if (typeof count !== "number" || !Number.isFinite(count)) return "";
                    if (countUrl) return `Ôºà<a href="${escapeHtml(countUrl)}" target="_blank" rel="noopener">${escapeHtml(String(count))}</a>Ôºâ`;
                    return `Ôºà${escapeHtml(String(count))}Ôºâ`;
                };
                const textBlock = textGroups.length
                    ? textGroups.map((group, idx) => {
                        const text = group?.text;
                        const chapters = Array.isArray(group?.chapters) ? group.chapters : [];
                        const textLink = text
                            ? (text.url
                                ? `<a href="${escapeHtml(text.url)}" target="_blank" rel="noopener">${escapeHtml(text.label)}</a>${renderCount(text.count, text.countUrl)}`
                                : `${escapeHtml(text.label)}${renderCount(text.count, text.countUrl)}`)
                            : "‚Äî";
                        const chapterLinks = chapters
                            .map(ch => {
                                const chapterLabel = ch?.url
                                    ? `<a href="${escapeHtml(ch.url)}" target="_blank" rel="noopener">${escapeHtml(ch.label || "")}</a>`
                                    : `${escapeHtml(ch?.label || "")}`;
                                return `${chapterLabel}${renderCount(ch?.count, ch?.countUrl)}`;
                            })
                            .filter(Boolean)
                            .join("Ôºõ");
                        const suffix = chapterLinks ? ` - ${chapterLinks}` : "";
                        if (idx === 0) {
                            return `<div class="ctext-text-group"><strong class="ctext-text-prefix">${t.textLabel}</strong><span class="ctext-text-content">${textLink}${suffix}</span></div>`;
                        }
                        return `<div class="ctext-text-group ctext-text-group-cont"><span class="ctext-text-content">${textLink}${suffix}</span></div>`;
                    }).join("")
                    : `<div class="ctext-text-group"><strong class="ctext-text-prefix">${t.textLabel}</strong><span class="ctext-text-content">‚Äî</span></div>`;

                const debugBlock = ctextDebug && item.debug ? `
                    <details class="ctext-debug">
                        <summary>debug lines</summary>
                        <div>attempts: ${escapeHtml(String(item.attempts ?? "‚Äî"))}</div>
                        <div>source endpoint: ${escapeHtml(item.sourceEndpoint || "‚Äî")}</div>
                        <div>query used: ${escapeHtml(item.queryUsed || item?.debug?.queryUsed || "‚Äî")}</div>
                        <pre>${escapeHtml(JSON.stringify(item.debug, null, 2))}</pre>
                    </details>
                ` : "";

                return `
                    <article class="ctext-result-item">
                        <div class="ctext-result-variant">${t.variantTerm}<code>${escapeHtml(item.variant || "")}</code></div>
                        <div class="ctext-result-meta">
                            <div><strong>${t.scope}</strong>${escapeHtml(scopeDisplay || "‚Äî")}</div>
                            ${typeDisplay ? `<div><strong>${t.type}</strong>${escapeHtml(typeDisplay)}</div>` : ""}
                            <div><strong>${t.condition}</strong>${escapeHtml(conditionDisplay || "‚Äî")}</div>
                            <div><strong>${t.matched}</strong>${hasNumericHit && item?.searchUrl ? `<a href="${escapeHtml(item.searchUrl)}" target="_blank" rel="noopener">${escapeHtml(hitCountDisplay)}</a>` : escapeHtml(hitCountDisplay)}</div>
                        </div>
                        <div class="ctext-result-structure">${textBlock}</div>
                        ${debugBlock}
                    </article>
                `;
            }).join("");

            body.innerHTML = `
                <p class="ctext-query"><strong>${t.query}</strong>${escapeHtml(term)}</p>
                <p class="ctext-query-sub">${t.variantSearch}Ôºà${escapeHtml(payload?.variantsSearched ?? (payload?.variants || []).length)}ÔºâÔºö${escapeHtml((payload.variants || []).join(" / ")) || "‚Äî"}</p>
                ${blocks || `<p class='ctext-empty'>${t.noResult}</p>`}
            `;
            openCtextPanelWithEnterAnimation(panel);
        }

        async function requestCtextSearch(term, queryKey) {
            const path = window.location.pathname || "";
            const basePrefix = path.includes("/transcriptions/")
                ? path.split("/transcriptions/")[0]
                : "";
            const params = new URLSearchParams(window.location.search);
            const ctextDebug = params.get("ctextDebug") === "1";
            const forceRefresh = params.get("ctextRefresh") === "1";
            const normalizedKey = normalizeLookupKey(queryKey || term) || (term || "").trim();
            const cacheKey = `q=${normalizedKey}|debug=${ctextDebug ? 1 : 0}|refresh=${forceRefresh ? 1 : 0}`;
            if (!forceRefresh && ctextResultCache.has(cacheKey)) {
                return ctextResultCache.get(cacheKey);
            }
            if (ctextInFlightCache.has(cacheKey)) {
                return ctextInFlightCache.get(cacheKey);
            }

            const apiUrl = `${basePrefix}/api/ctext/search?q=${encodeURIComponent(normalizedKey)}${ctextDebug ? "&debug=1" : ""}${forceRefresh ? "&refresh=1" : ""}`;
            const reqPromise = (async () => {
                const res = await fetch(apiUrl, {
                    headers: { "Accept": "application/json" }
                });
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                return res.json();
            })();
            ctextInFlightCache.set(cacheKey, reqPromise);
            try {
                const payload = await reqPromise;
                if (!forceRefresh) ctextResultCache.set(cacheKey, payload);
                return payload;
            } finally {
                ctextInFlightCache.delete(cacheKey);
            }
        }

        function initCtextLookupForNodeHits(container) {
            if (!container || container.dataset.ctextLookupReady === "1") return;
            container.dataset.ctextLookupReady = "1";

            container.addEventListener("dblclick", async (event) => {
                const hit = event.target.closest(".tei-node-hit");
                if (!hit || !container.contains(hit)) return;
                const term = (hit.textContent || "").trim();
                if (!term) return;
                const queryKey = hit.dataset.queryKey || normalizeLookupKey(term) || term;

                event.preventDefault();
                event.stopPropagation();
                renderCtextLoading(term);
                try {
                    const data = await requestCtextSearch(term, queryKey);
                    renderCtextResults(term, data);
                } catch (err) {
                    renderCtextError(term, err?.message || "request failed");
                }
            });
        }

        // Minimal TEI ‚Üí HTML mapping
        function teiNodeToHTML(node) {
            // Text nodes
            console.log("NODE:", node.localName);  // ‚Üê Ëøô‰∏ÄË°åÊñ∞Âä†ÁöÑÔºåË∞ÉËØïÊ†áÁ≠æÁî®ÔºàÂç≥ÂµåÂ•óÁöÑXMLÁªìÊûÑËÉΩÂê¶Ê≠£Á°ÆÂú®ÁΩëÈ°µÁ´ØË¢´Ê∏≤ÊüìÂá∫Êù•ÔºåËøôÊ¨°Ëß£ÂÜ≥‰∫Üunclear‰∏çË¢´ÊòæÁ§∫‰∏∫ÈóÆÂè∑ÁöÑÊÉÖÂÜµÔºâ
            if (node.outerHTML) console.log("RAW:", node.outerHTML);  // ‚Üê Ëøô‰∏ÄË°åÊñ∞Âä†ÁöÑÔºå‰øùÁïô‰∏∫Ë∞ÉËØïÊ®°ÊùøÔºåÂú®Â§ßÂûã XML È°πÁõÆ‰∏≠ÊúâÂä©‰∫éÊéíÊü• namespace ‰∏¢Â§±ÔºåÂèØÊ≥®ÈáäÊéâ
            if (node.nodeType === Node.TEXT_NODE) {
                return document.createTextNode(node.nodeValue);
            }

            // Ignore comments and processing instructions
            if (node.nodeType !== Node.ELEMENT_NODE) {
                return document.createDocumentFragment();
            }

            const name = node.localName; // works regardless of TEI namespace
            const frag = document.createDocumentFragment();

            // Helper to render children
            const renderChildren = (parentEl = null) => {
                const container = parentEl || document.createDocumentFragment();
                for (const child of node.childNodes) {
                    container.appendChild(teiNodeToHTML(child));
                }
                return container;
            };

            // Map a few common TEI elements
            switch (name) {
                case "TEI":
                case "teiCorpus": {
                    const wrapper = el("article", "tei-doc");
                    wrapper.appendChild(renderChildren());
                    return wrapper;
                }
                case "teiHeader": {
                    // Skip header in main view but keep title if present
                    const titleStmt = node.getElementsByTagNameNS("*", "titleStmt")[0];
                    const titleEl = titleStmt?.getElementsByTagNameNS("*", "title")[0];
                    if (titleEl) {
                        const h1 = el("h1");
                        h1.textContent = textContentDeep(titleEl);
                        return h1;
                    }
                    return document.createDocumentFragment();
                }
                case "text": {
                    const section = el("section");
                    section.appendChild(renderChildren());
                    return section;
                }
                case "body": {
                    const main = el("div", "tei-body");
                    main.appendChild(renderChildren());
                    return main;
                }
                case "div": {
                    const subtype = (node.getAttribute("subtype") || "").toLowerCase();
                    const div = el("section", "tei-div");
                    if (subtype === "diplomatic") div.classList.add("tei-transcription-primary");
                    if (subtype === "simplified") div.classList.add("tei-transcription-simplified");
                    if (subtype === "critical") div.classList.add("tei-edited-fixed");
                    const hideXmlHeadForTranscription = subtype === "diplomatic" || subtype === "simplified";
                    // optional direct head within div
                    const head = Array.from(node.children || []).find((child) => child.localName === "head");
                    if (head && !hideXmlHeadForTranscription) {
                        const h2 = el("h2");
                        h2.textContent = textContentDeep(head);
                        div.appendChild(h2);
                    }
                    for (const child of node.childNodes) {
                        if (child.nodeType === Node.ELEMENT_NODE && child.localName === "head") continue;
                        div.appendChild(teiNodeToHTML(child));
                    }
                    return div;
                }
                case "p": {
                    const p = el("p");
                    p.appendChild(renderChildren());
                    return p;
                }
                case "head": {
                    const h2 = el("h2");
                    h2.appendChild(renderChildren());
                    return h2;
                }
                case "lb": {
                    return el("br");
                }
                case "pb": {
                    const span = el("span", "tei-pb");
                    const n = node.getAttribute("n");
                    const facs = node.getAttribute("facs");
                    span.setAttribute("title", n ? `Page break: ${n}` : "Page break");
                    // ÊòæÁ§∫‰∏≠ÊÄßÁ¨¶Âè∑ÔºåÈÅøÂÖçÂíå verse bar Ê∑∑Ê∑Ü
                    span.textContent = n ? ` [${n}] ` : " [pb] ";
                    return span;
                }
                case "note": {
                    const place = node.getAttribute("place");

                    // ‚Äî‚Äî A Á±ªÔºöÂÜÖËÅîÊ≥®ÈáäÔºàinlineÔºâ ‚Äî‚Äî
                    if (place === "inline") {
                        const span = el("span", "tei-note-inline");
                        span.title = "inline note";   // hover tooltip
                        span.appendChild(renderChildren());
                        return span;
                    }

                    // ‚Äî‚Äî B Á±ªÔºöÊôÆÈÄöËÑöÊ≥®Ôºà‰øùÁïôÂéüÊ†∑Ôºâ ‚Äî‚Äî
                    const aside = el("aside", "tei-note");
                    aside.appendChild(renderChildren());
                    return aside;
                }

                case "hi": {
                    const rend = node.getAttribute("rend") || "";
                    const tag = /italic|em/.test(rend) ? "em" : /bold|strong/.test(rend) ? "strong" : "span";
                    const elx = el(tag);
                    elx.appendChild(renderChildren());
                    return elx;
                }
                case "q": {
                    const q = el("blockquote");
                    q.appendChild(renderChildren());
                    return q;
                }
                case "list": {
                    const listType = node.getAttribute("type") || "";
                    const ul = el(listType === "ordered" ? "ol" : "ul");
                    ul.appendChild(renderChildren());
                    return ul;
                }
                case "item": {
                    const li = el("li");
                    li.appendChild(renderChildren());
                    return li;
                }
                case "lg": {
                    const div = el("div", "tei-lg");
                    div.appendChild(renderChildren());
                    return div;
                }
                case "l": {
                    const p = el("p", "tei-line");
                    p.appendChild(renderChildren());
                    return p;
                }
                case "ref": {
                    const a = el("a");
                    const href = node.getAttribute("target") || node.getAttribute("url") || "#";
                    a.href = href;
                    a.appendChild(renderChildren());
                    return a;
                }
                case "gap": {
                    // ÊòæÁ§∫Áº∫Â≠óÁ¨¶Âè∑ÔºåÂ¶Ç +++
                    const qty = node.getAttribute("quantity");
                    const span = el("span", "tei-gap");
                    const symbol = "+";
                    span.textContent = qty ? symbol.repeat(Number(qty)) : symbol.repeat(3);
                    return span;
                }

                case "supplied": {
                    // ÊòæÁ§∫ÈáçÂª∫ÁöÑÂÜÖÂÆπ <...>
                    const span = el("span", "tei-supplied");
                    // Ê£ÄÊü•ÊòØÂê¶ÂéüÊú¨ÂåÖÂê´ <unclear>
                    const hasUnclear = node.getElementsByTagName("unclear").length > 0;
                    const text = textContentDeep(node);
                    if (hasUnclear) {
                        // Ê≠£Â∏∏ÊòæÁ§∫ <?‡§É>
                        span.textContent = "<?" + text + ">";
                    } else {
                        // Ê≤°ÊúâunclearÂ≠êËäÇÁÇπÊó∂Ôºå‰øùÁïôÂéüÈÄªËæë
                        span.textContent = "<" + text + ">";
                    }
                    return span;
                }


                case "unclear": {
                    const span = el("span", "tei-unclear");
                    const text = textContentDeep(node);

                    // console.log("UNCLEAR NODE:", text);  ‚Üê Ëøô‰∏§Ë°åÊñ∞Âä†ÁöÑÔºåË∞ÉËØïunclearÊ†áÁ≠æÂú®ÁΩëÈ°µinspectÈÉ®ÂàÜÁöÑconsoleÈáådebugÁî®
                    // console.log("FINAL OUTPUT:", `<?${text}>`);  // ‚Üê Ëøô‰∏§Ë°åÊñ∞Âä†ÁöÑÔºå‰ªÖ‰∏∫debugËæìÂá∫ÁªìÊûúÁî®

                    if (node.parentNode && node.parentNode.localName === "supplied") {
                        span.textContent = `<?${text}>`;
                    } else {
                        span.textContent = `<${text}>`;
                    }

                    return span;
                }

                case "facsimile":
                case "surface": {
                    const div = el("div", "tei-facsimile");
                    div.appendChild(renderChildren());
                    return div;
                }

                case "graphic": {
                    const img = document.createElement("img");
                    const src = node.getAttribute("url") || node.getAttribute("target");

                    img.src = src;
                    img.alt = "Manuscript image";
                    img.className = "tei-graphic";  // ‰∏ÄÂæãÁî®Áº©Áï•ÂõæÊ†∑Âºè

                    // ÁÇπÂáªÔºöÂÖ®Â±èÊòæÁ§∫ÂéüÂõæ
                    img.addEventListener("click", () => {
                        const overlay = document.createElement("div");
                        overlay.className = "tei-image-overlay";

                        const full = document.createElement("img");
                        full.src = src;
                        full.className = "tei-image-full";

                        overlay.appendChild(full);
                        document.body.appendChild(overlay);

                        overlay.addEventListener("click", () => overlay.remove());
                    });

                    return img;
                }


                case "fw": {
                    // running title/page header ‰∏çÂ∫îËØ•ÊòæÁ§∫Âú®Ê≠£Êñá
                    return document.createDocumentFragment();
                }

                case "desc":
                case "sourceDesc": {
                    // ‰∏çÊòæÁ§∫‰ªª‰ΩïÊñáÂ≠ó
                    return document.createDocumentFragment(); // ÂøΩÁï•ÊòæÁ§∫
                }

                case "listBibl": {
                    const section = el("section", "tei-bibl");
                    section.appendChild(renderChildren());
                    return section;
                }

                case "bibl": {
                    const p = el("p", "tei-bibl-item");

                    // ‚Äî‚Äî ËØÜÂà´ monograph Ê†ºÂºè ‚Äî‚Äî
                    const isMono = node.querySelector("title[level='m']");

                    if (isMono) {
                        const authors = [...node.querySelectorAll("author")]
                            .map(a => a.textContent.trim())
                            .join("Ôºõ");

                        const title = node.querySelector("title[level='m']")?.textContent.trim() || "";
                        const pubPlace = node.querySelector("pubPlace")?.textContent.trim() || "";
                        const publisher = node.querySelector("publisher")?.textContent.trim() || "";
                        const date = node.querySelector("date")?.textContent.trim() || "";
                        const pages = node.querySelector("biblScope[unit='page']")?.textContent.trim() || "";

                        // ‚Äî‚Äî HTML ËæìÂá∫Âè•Â≠êÔºàÊúÄÁªàÁΩëÈ°µ‰ºöÂëàÁé∞Êàê‰Ω†Ë¶ÅÁöÑÊ†ºÂºèÔºâ ‚Äî‚Äî
                        p.textContent =
                            `${authors}Ôºö„Ää${title}„ÄãÔºå${pubPlace}Ôºö${publisher}Ôºå${date}Âπ¥ÁâàÔºå${pages ? `Á¨¨ ${pages} È†Å„ÄÇ` : ""}`;

                        return p;
                    }

                    // ‚Äî‚Äî ÂÖ∂‰ªñÁ±ªÂûãÁöÑ biblÔºàÂ¶Ç journal ÊñáÁ´†Ôºâ‰øùÊåÅÂéüÊúâÈÄªËæë ‚Äî‚Äî

                    p.appendChild(renderChildren());
                    return p;
                }

                case "biblHead":  // ‚Üê ÊîπÊàêËá™ÂÆö‰πâÊ†áÁ≠æÂêçÈÅøÂÖçÂÜ≤Á™Å
                case "headBibl":  // ‰ªªÈÄâ‰∏Ä‰∏™Ôºå‰∏ãÈù¢‰∏§Ë°åÂä†ËØ¥Êòé
                    const h3 = el("h3");
                    h3.appendChild(renderChildren());
                    return h3;

                case "title": {
                    const level = node.getAttribute("level") || "";
                    const type = node.getAttribute("type") || "";

                    // ÊúüÂàäÂêç / monograph ‚Üí Êñú‰Ωì
                    if (level === "j" || level === "m") {
                        const em = el("em", "tei-title");
                        em.appendChild(renderChildren()); // ‚úÖ ‰øùÁïôÂ≠êËäÇÁÇπÔºàÂÖÅËÆ∏ÂµåÂ•óÔºâ
                        return em;
                    }

                    // ÊñáÁ´†Ê†áÈ¢ò ‚Üí Âä†ÂºïÂè∑Âπ∂‰øùÁïôÂ≠êÂÖÉÁ¥†
                    if (level === "a") {
                        const span = el("span", "tei-title-article");
                        span.appendChild(renderChildren()); // ‚úÖ ÊîπÊàê renderChildren()
                        // Ëá™Âä®Ê∑ªÂä†ÂºïÂè∑
                        const quoted = el("span");
                        quoted.textContent = "‚Äú";
                        span.prepend(quoted);
                        const quotedEnd = el("span");
                        quotedEnd.textContent = "‚Äù";
                        span.appendChild(quotedEnd);
                        return span;
                    }

                    // ÈªòËÆ§ÊÉÖÂÜµ
                    const span = el("span", "tei-title");
                    span.appendChild(renderChildren());
                    return span;
                }


                default: {
                    // Unknown TEI element: render its children inline
                    return renderChildren();
                }
            }
        }

        function placeHanshuLineInteractionHint(container) {
            const hint = document.getElementById("lineInteractionHintHanshu");
            if (!(hint instanceof HTMLElement)) return;
            const bibl = container?.querySelector?.(".tei-bibl");
            if (bibl instanceof HTMLElement && bibl.parentElement) {
                bibl.parentElement.insertBefore(hint, bibl);
                return;
            }
            const xmlLink = document.querySelector(".xml-link-block");
            if (xmlLink instanceof HTMLElement) {
                xmlLink.insertAdjacentElement("beforebegin", hint);
                return;
            }
            container?.insertAdjacentElement?.("afterend", hint);
        }

        function placeHanshuScriptButton(container) {
            const button = document.getElementById("scriptToggleButtonHanshu");
            if (!(button instanceof HTMLElement)) return;
            const primary = container.querySelector(".tei-transcription-primary");
            if (!(primary instanceof HTMLElement) || !primary.parentElement) {
                button.hidden = true;
                return;
            }

            let row = container.querySelector(".tei-head-with-script.hanshu-transcription-toolbar");
            if (!(row instanceof HTMLElement)) {
                row = document.createElement("div");
                row.className = "tei-head-with-script hanshu-transcription-toolbar";
                const title = document.createElement("h2");
                title.textContent = "Transcription";
                row.appendChild(title);
                primary.parentElement.insertBefore(row, primary);
            }

            button.hidden = false;
            if (button.parentElement !== row) {
                row.appendChild(button);
            }
        }

        // Utilities
        function el(tag, className) {
            const e = document.createElement(tag);
            if (className) e.className = className;
            return e;
        }
        function textContentDeep(node) {
            let s = "";
            const walker = document.createTreeWalker(node, NodeFilter.SHOW_TEXT, null);
            let n;
            while ((n = walker.nextNode())) s += n.nodeValue;
            return s.trim();
        }

        // Call it with your file name and target container
        // Example: a file at ./sample.xml -> render into #tei-container
        loadTEI("lingyue.xml", "#tei-container");

        const backButton = document.getElementById("legacyBackButton");
        const hanshuScriptButton = document.getElementById("scriptToggleButtonHanshu");
        hanshuScriptButton?.addEventListener("click", async () => {
            const nextMode = hanshuScriptMode === "traditional" ? "simplified" : "traditional";
            await applyHanshuScriptMode(nextMode);
            const container = document.getElementById("tei-container");
            if (container) {
                await runNodeHighlightPrototype(container, "lingyue.xml");
            }
        });
        backButton?.addEventListener("click", () => {
            if (window.history.length > 1) {
                window.history.back();
                return;
            }
            window.location.href = "../../transcriptions/";
        });
    </script>

    <style>
        /* Minimal styling */
        .tei-doc {
            line-height: 1.6;
        }

        .tei-note {
            font-size: 0.95em;
            padding-left: 0.8rem;
            border-left: 3px solid #ddd;
            margin: 0.5rem 0;
        }

        .tei-pb {
            opacity: 0.6;
            font-size: 0.9em;
        }

        .tei-div {
            margin: 1rem 0;
        }

        .tei-transcription-primary {
            margin-bottom: 2rem;
        }

        .tei-transcription-simplified[hidden] {
            display: none !important;
        }

        .tei-line {
            margin: 0;
        }

        /* ‚Äî‚Äî inline Ê≥®ÈáäÔºöÂíåÊ≠£ÊñáÂêå‰∏ÄË°åÔºåÊó†ÁÅ∞Á∫ø ‚Äî‚Äî */
        .tei-note-inline {
            color: #7a4e00;
            /* Ê≥®ÈáäÂ≠óÈ¢úËâ≤ÔºàÂèØÊîπÔºâ */
            font-size: 0.9em;
            display: inline;
            cursor: pointer;
            padding: 0 0.15em;
            border-radius: 3px;
        }

        /* Ëá™Âä®Âä†‰∏≠Êã¨Âè∑ */
        .tei-note-inline::before {
            content: "[";
        }

        .tei-note-inline::after {
            content: "]";
        }

        /* hover È´ò‰∫ÆÊòæÁ§∫ tooltip */
        .tei-note-inline:hover {
            color: #a56300;
            background-color: rgba(255, 225, 170, 0.3);
        }

        .tei-node-hit {
            color: #6f4a12;
            background:
                linear-gradient(180deg,
                    rgba(255, 236, 189, 0) 46%,
                    rgba(255, 221, 156, 0.58) 46%,
                    rgba(255, 221, 156, 0.58) 100%);
            border-radius: 0.2em;
            padding: 0 0.08em;
            transition: color 0.2s ease, background-color 0.2s ease;
            cursor: pointer;
            border-bottom: 1px dotted rgba(111, 74, 18, 0.45);
        }

        .tei-node-hit:hover {
            color: #8a5a1a;
            background-color: rgba(255, 225, 170, 0.34);
        }

        .ctext-result-panel {
            position: fixed;
            top: 88px;
            width: min(420px, 38vw);
            max-height: calc(100vh - 110px);
            background: rgba(255, 252, 246, 0.98);
            border: 1px solid rgba(122, 96, 68, 0.3);
            border-radius: 12px;
            box-shadow: 0 14px 30px rgba(28, 22, 16, 0.18);
            --panel-enter-x: 110%;
            transform: translateX(var(--panel-enter-x));
            opacity: 0;
            transition: transform 0.25s ease, opacity 0.2s ease;
            z-index: 1300;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .ctext-result-panel.is-resizing {
            transition: none;
            user-select: none;
        }

        .ctext-resize-handle {
            position: absolute;
            top: 0.65rem;
            bottom: 0.65rem;
            width: 12px;
            z-index: 4;
            cursor: ew-resize;
            border-radius: 6px;
            opacity: 0;
            transition: opacity 0.15s ease;
        }

        .ctext-result-panel:hover .ctext-resize-handle {
            opacity: 1;
        }

        .ctext-result-panel.side-right {
            right: 14px;
            left: auto;
            --panel-enter-x: 110%;
        }

        .ctext-result-panel.side-right .ctext-resize-handle {
            left: -6px;
            background: linear-gradient(270deg, rgba(74, 62, 48, 0.05), rgba(74, 62, 48, 0.2));
        }

        .ctext-result-panel.side-left {
            left: 14px;
            right: auto;
            --panel-enter-x: -110%;
        }

        .ctext-result-panel.side-left .ctext-resize-handle {
            right: -6px;
            background: linear-gradient(90deg, rgba(74, 62, 48, 0.05), rgba(74, 62, 48, 0.2));
        }

        @media (min-width: 1260px) {
            .ctext-result-panel {
                width: var(--hanshu-side-panel-width);
            }

            #hanshuNodePanel.node-entry-panel {
                width: var(--hanshu-side-panel-width);
                max-height: calc(100vh - 110px);
            }

            #hanshuNodePanel.node-entry-panel .node-entry-body {
                max-height: calc(100vh - 198px);
            }
        }

        .ctext-result-panel.is-open {
            transform: translateX(0);
            opacity: 1;
        }

        .ctext-panel-head {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.65rem 0.75rem;
            background: #f5ebdd;
            border-bottom: 1px solid rgba(122, 96, 68, 0.26);
        }

        .ctext-panel-title {
            font-size: 0.88rem;
            font-weight: 700;
            color: #4f3d29;
            letter-spacing: 0.04em;
        }

        .ctext-close-btn {
            border: none;
            background: transparent;
            font-size: 1.08rem;
            color: #6b5740;
            cursor: pointer;
            line-height: 1;
        }

        .ctext-lang-switch {
            display: inline-flex;
            gap: 0.22rem;
            margin-left: auto;
            margin-right: 0.25rem;
        }

        .ctext-lang-btn {
            border: 1px solid rgba(122, 96, 68, 0.38);
            background: #f5eee2;
            color: #5b472f;
            font-size: 0.68rem;
            line-height: 1;
            padding: 0.18rem 0.33rem;
            border-radius: 999px;
            cursor: pointer;
        }

        .ctext-lang-btn.is-active {
            background: #e5d7c3;
            border-color: rgba(103, 77, 49, 0.58);
            color: #3e2f20;
            font-weight: 700;
        }

        .ctext-panel-body {
            padding: 0.72rem 0.8rem 0.9rem;
            overflow: auto;
            font-size: 0.82rem;
            color: #3f3327;
            line-height: 1.5;
        }

        .ctext-query {
            margin: 0 0 0.3rem;
        }

        .ctext-query-sub {
            margin: 0 0 0.6rem;
            color: #6f5d49;
            font-size: 0.76rem;
        }

        .ctext-loading,
        .ctext-empty,
        .ctext-error,
        .ctext-hint {
            margin: 0.35rem 0 0.5rem;
        }

        .ctext-error {
            color: #8a3d2f;
        }

        .ctext-result-item {
            border: 1px solid rgba(122, 96, 68, 0.22);
            border-radius: 8px;
            padding: 0.5rem 0.55rem;
            margin-bottom: 0.58rem;
            background: rgba(255, 255, 255, 0.66);
        }

        .ctext-result-variant {
            margin-bottom: 0.35rem;
            color: #5b472f;
        }

        .ctext-result-meta div,
        .ctext-result-structure div {
            margin-bottom: 0.18rem;
        }

        .ctext-text-group {
            margin-bottom: 0.3rem;
            line-height: 1.5;
        }

        .ctext-text-prefix {
            display: inline-block;
            vertical-align: top;
            margin-right: 0.1rem;
            white-space: nowrap;
        }

        .ctext-text-group-cont {
            padding-left: 4.1em;
        }

        .ctext-text-content {
            display: inline;
        }

        .ctext-text-group a {
            color: #5f4325;
            text-decoration: none;
        }

        .ctext-text-group a:hover {
            text-decoration: underline;
        }

        .ctext-fallback-links {
            margin: 0.25rem 0 0.4rem 1.1rem;
            padding: 0;
        }

        @media (max-width: 980px) {
            .ctext-result-panel {
                width: min(460px, 92vw);
                top: 76px;
                max-height: calc(100vh - 90px);
            }

            .ctext-result-panel.side-right {
                right: 4vw;
                left: auto;
            }

            .ctext-result-panel.side-left {
                left: 4vw;
                right: auto;
            }
        }

        .node-hit-head {
            display: flex;
            align-items: center;
            gap: 0.6rem;
            margin-top: 0.45rem;
            margin-bottom: 0.25rem;
            flex-wrap: wrap;
        }

        .node-hit-toggle-btn {
            border: 1px solid rgba(122, 96, 68, 0.28);
            border-radius: 8px;
            background: #f6efe5;
            color: #4f3d29;
            font-family: Georgia, serif;
            font-size: 0.82rem;
            padding: 0.28rem 0.55rem;
            cursor: pointer;
            box-shadow: 0 2px 0 rgba(74, 62, 48, 0.18);
            transition: background-color 0.2s ease, transform 0.15s ease;
        }

        .node-hit-toggle-btn:hover {
            background: #efe5d8;
        }

        .node-hit-toggle-btn:active {
            transform: translateY(1px);
        }

        .node-hit-panel {
            max-height: 0;
            opacity: 0;
            overflow: hidden;
            transform: translateY(-3px);
            transition: max-height 0.32s ease, opacity 0.24s ease, transform 0.24s ease;
        }

        .node-hit-panel.is-open {
            max-height: 520px;
            opacity: 1;
            transform: translateY(0);
        }

        .node-hit-details {
            margin: 0.25rem 0 0.8rem;
            font-size: 0.82rem;
            color: #4b3d2d;
        }

        .node-hit-details summary {
            cursor: pointer;
            font-weight: 600;
            margin-bottom: 0.35rem;
        }

        .node-hit-details ul {
            margin: 0;
            padding-left: 1.1rem;
            columns: 2;
            column-gap: 1.2rem;
        }

        .node-hit-details li {
            list-style: disc;
            background: transparent;
            box-shadow: none;
            padding: 0;
            margin: 0 0 0.2rem 0;
            border-radius: 0;
            break-inside: avoid;
        }

        .node-hit-details code {
            background: rgba(255, 243, 219, 0.65);
            border-radius: 4px;
            padding: 0.02rem 0.24rem;
            font-size: 0.78rem;
        }

        .node-hit-details span {
            color: #7a654a;
            margin-left: 0.25rem;
        }

        .node-hit-variants {
            display: inline-block;
            margin-left: 0.46rem;
            color: #7a654a;
            font-size: 0.74rem;
        }


        /* ‚Äî‚Äî block Ê≥®ÈáäÔºàËÑöÊ≥®Ôºâ‰æùÁÑ∂‰øùÊåÅÁ´ñÁ∫ø ‚Äî‚Äî */
        .tei-note {
            font-size: 0.95em;
            padding-left: 0.8rem;
            border-left: 3px solid #ddd;
            /* ÁÅ∞Á´ñÁ∫ø‰øùÁïô */
            margin: 0.5rem 0;
        }

        /* ËÆ©ËÑöÊ≥®Áã¨Á´ãÊç¢Ë°å */
        .tei-note-block {
            display: block;
            margin: 0.5em 0;
        }

        /* Override default graphic style: show as thumbnail */
        .tei-graphic {
            max-width: 180px;
            /* ÈªòËÆ§Áº©Áï•ÂõæÂÆΩÂ∫¶ */
            height: auto;
            display: block;
            margin: 1.2em auto 2.05em;
            border-radius: 6px;
            cursor: zoom-in;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
        }

        /* ÁÇπÂáªÂêéÊîæÂ§ßÁöÑËÉåÊôØ */
        .tei-image-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.75);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 99999;
            cursor: zoom-out;
        }

        /* ÊîæÂ§ßÁöÑÂ§ßÂõæ */
        .tei-image-full {
            max-width: 90%;
            max-height: 90%;
            border-radius: 8px;
            box-shadow: 0 0 12px rgba(255, 255, 255, 0.8);
        }

        .tei-bibl {
            margin-top: 2em;
            padding-top: 1.1em;
            position: relative;
        }

        .tei-bibl::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(90, 74, 56, 0.4), transparent);
        }

        .tei-bibl-item {
            margin-left: 1em;
            line-height: 1.6;
        }

        .tei-title {
            font-style: italic;
        }

        .tei-title-article {
            font-style: normal;
        }
    </style>

</body>

</html>
