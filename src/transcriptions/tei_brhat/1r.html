<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../../css/style.css" />
    <style>
        :root {
            --transcription-mini-heading-size: 1.2rem;
            --folio-nav-inline-gap: clamp(0.95rem, 2.2vw, 2.35rem);
        }

        body {
            margin: 0;
            padding: 0;
            font-family: Georgia, 'Times New Roman', serif;
            background-color: #f5f0e7;
            color: #352f28;
            line-height: 1.6;
        }

        .tei-page {
            max-width: min(1680px, 98vw);
            margin: auto;
            padding: 0 0.8em 2em;
            position: relative;
        }

        .folio-hero {
            position: relative;
            height: clamp(420px, 70vh, 860px);
            border-radius: 0;
            overflow: hidden;
            margin: 0 calc(50% - 50vw) 3.35rem;
            background: #111;
        }

        .folio-hero-image {
            position: absolute;
            inset: -45% -12%;
            background: 60% 50% / cover no-repeat;
            transform: translateY(var(--hero-parallax, 0px)) scale(1.34);
            transform-origin: left center;
            transition: transform 0.15s linear, opacity 0.35s ease, filter 0.35s ease;
            opacity: 0.96;
            filter: saturate(1.28) contrast(1.18) brightness(1.03);
        }

        .folio-hero-overlay {
            position: absolute;
            inset: 0;
            background:
                linear-gradient(180deg, rgba(4, 4, 4, 0.68) 0%, rgba(4, 4, 4, 0.4) 8%, rgba(4, 4, 4, 0.17) 16%, rgba(4, 4, 4, 0) 30%),
                linear-gradient(118deg, rgba(248, 245, 242, 0.1), rgba(248, 245, 242, 0) 44%);
            pointer-events: none;
        }

        .folio-hero-meta {
            position: absolute;
            right: 1.1rem;
            bottom: 0.9rem;
            color: #f4ede3;
            font-size: 0.82rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            text-shadow: 0 1px 8px rgba(0, 0, 0, 0.45);
        }

        .folio-hero-title {
            position: absolute;
            left: clamp(1.1rem, 5vw, 10rem);
            top: auto;
            bottom: clamp(1.05rem, 6vh, 4rem);
            max-width: min(68vw, 920px);
            color: #fff;
            font-size: clamp(2rem, 4.8vw, 4.4rem);
            line-height: 1.1;
            font-weight: 700;
            text-shadow: 0 5px 22px rgba(0, 0, 0, 0.6);
            z-index: 2;
            pointer-events: none;
        }

        .folio-nav-btn {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: auto;
            height: auto;
            border: none;
            border-radius: 0;
            background: transparent;
            color: rgba(248, 243, 235, 0.95);
            cursor: pointer;
            font-size: clamp(3.1rem, 6vw, 6rem);
            letter-spacing: -0.1em;
            font-weight: 800;
            font-family: "Arial Black", "Helvetica Neue", Helvetica, Arial, sans-serif;
            line-height: 1;
            opacity: 0;
            transition: opacity 0.18s ease, transform 0.18s ease, color 0.18s ease;
            text-shadow: 0 8px 18px rgba(0, 0, 0, 0.52);
            z-index: 2;
        }

        .folio-nav-btn:hover {
            transform: translateY(-50%) scale(1.05);
            color: #fff;
        }

        .folio-nav-prev {
            left: var(--folio-nav-inline-gap);
        }

        .folio-nav-next {
            right: var(--folio-nav-inline-gap);
        }

        .folio-hero:hover .folio-nav-btn,
        .folio-hero:focus-within .folio-nav-btn {
            opacity: 1;
        }

        h1 {
            font-size: 2em;
            margin-bottom: 1.45em;
            padding-bottom: 0.3em;
            border-bottom: none;
            position: relative;
        }

        h1::after {
            content: "";
            display: block;
            margin-top: 0.5rem;
            width: 100%;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(90, 74, 56, 0.4), transparent);
        }

        p {
            margin-bottom: 2em;
        }

        a {
            text-decoration: none;
            color: #0066cc;
            font-weight: bold;
            transition: color 0.3s ease;
        }

        a:hover {
            color: #004499;
        }

        ul {
            list-style: none;
            padding: 0;
        }

        li {
            background: #fff;
            padding: 1em;
            margin-bottom: 1em;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.06);
            transition: transform 0.2s ease;
        }

        li:hover {
            transform: translateY(-2px);
        }

        .no-link {
            color: #aaa;
            text-decoration: line-through;
            cursor: not-allowed;
            font-style: italic;
        }

        /* New CSS for the home icon */
        .home-link {
            position: absolute;
            top: 1em;
            left: -100px;
            /* Move it outside the left margin */
        }

        .home-link img {
            width: 88px;
            height: auto;
            border-radius: 4px;
            cursor: pointer;
            background-color: #fff;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
        }

        .home-link img:hover {
            box-shadow: 0 0 8px rgba(0, 0, 0, 0.3);
        }

        .legacy-back {
            position: fixed;
            left: 1rem;
            top: 1rem;
            z-index: 1400;
            pointer-events: none;
        }

        .transcription-tools {
            position: relative;
            min-height: 2.2rem;
            margin: 0.2rem 0 0.48rem;
            padding-right: 0.25rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.86rem;
        }

        .transcription-subtitle {
            text-transform: uppercase;
            letter-spacing: 0.2em;
            font-size: var(--transcription-mini-heading-size);
            font-weight: 700;
            color: #4c4034;
            margin: 0;
        }

        .cudl-title,
        .tei-doc h2,
        .tei-doc h3,
        .tei-bibl h2,
        .tei-bibl h3 {
            text-transform: uppercase;
            letter-spacing: 0.2em;
            font-size: var(--transcription-mini-heading-size);
            font-weight: 700;
            color: #4c4034;
            line-height: 1.2;
        }

        .script-toggle-button {
            border: none;
            border-radius: 8px;
            padding: 0.42rem 0.78rem;
            width: 8.2rem;
            background: #ebe1cf;
            color: #4a3e30;
            font-family: Georgia, serif;
            cursor: pointer;
            box-shadow: 0 2px 0 rgba(74, 62, 48, 0.18);
            transition: background-color 0.18s ease, transform 0.12s ease;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            white-space: nowrap;
            margin-left: auto;
        }

        .script-toggle-button:hover {
            background: #e6d9c4;
        }

        .script-toggle-button:active {
            transform: translateY(1px);
        }

        .script-toggle-button:disabled {
            opacity: 0.55;
            cursor: not-allowed;
        }

        .editor-toggle-button {
            width: auto;
            min-width: 7rem;
            margin-left: 0.4rem;
        }

        .tei-editor-on .tei-ab-line-text {
            outline: 1px dashed rgba(111, 74, 18, 0.45);
            outline-offset: 2px;
            border-radius: 4px;
        }

        .line-interaction-hint {
            display: block;
            font-size: 0.84rem;
            color: #6c5a46;
            line-height: 1.35;
            margin: 2rem 0 0.9rem;
        }

        .legacy-back-button {
            border: none;
            border-radius: 10px;
            padding: 0.48rem 0.84rem;
            background: rgba(43, 43, 43, 0.72);
            color: #f6efe5;
            font-family: Georgia, serif;
            cursor: pointer;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.28);
            transition: transform 0.15s ease, opacity 0.2s ease, background-color 0.2s ease;
            opacity: 0;
            transform: translateY(-10px);
            pointer-events: none;
        }

        .legacy-back.is-visible {
            pointer-events: auto;
        }

        .legacy-back.is-visible .legacy-back-button {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        .legacy-back-button:hover {
            background: rgba(43, 43, 43, 0.9);
        }

        .legacy-back-button:active {
            transform: translateY(1px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .floating-menu-toggle {
            position: fixed;
            right: 1rem;
            top: 1rem;
            z-index: 1500;
            width: 3.6rem;
            height: 3.6rem;
            border: none;
            border-radius: 0;
            background: rgba(56, 56, 56, 0.8);
            color: #f8f5f2;
            font-size: 1.95rem;
            cursor: pointer;
            box-shadow: 0 10px 24px rgba(0, 0, 0, 0.32);
            transition: background-color 0.18s ease, transform 0.18s ease;
        }

        .floating-menu-toggle:hover {
            background: rgba(56, 56, 56, 0.92);
            transform: translateY(-1px);
        }

        .floating-side-nav {
            position: fixed;
            top: 0;
            right: 0;
            height: 100vh;
            width: min(360px, 82vw);
            background: rgba(24, 24, 24, 0.94);
            color: #f2eee8;
            transform: translateX(102%);
            transition: transform 0.28s cubic-bezier(.2, .7, .12, 1);
            z-index: 1450;
            padding-top: 5.2rem;
            box-shadow: -12px 0 28px rgba(0, 0, 0, 0.38);
        }

        .floating-side-nav.open {
            transform: translateX(0);
        }

        .floating-nav-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.28);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 1400;
        }

        .floating-nav-backdrop.open {
            opacity: 1;
            pointer-events: auto;
        }

        .floating-side-nav a {
            display: block;
            color: #f2eee8;
            text-decoration: none;
            padding: 1rem 1.2rem;
            border-top: 1px solid rgba(255, 255, 255, 0.12);
            font-size: 1.12rem;
            font-weight: 500;
        }

        .floating-side-nav a:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .xml-link-block {
            margin-top: 1.6rem;
            font-size: 0.88rem;
            color: #5a4d3d;
            display: inline-block;
        }

        .xml-link-block a {
            font-size: 0.88rem;
            color: #4b3a23;
            text-decoration: none;
            font-weight: 600;
        }

        .xml-link-block a:hover {
            text-decoration: underline;
        }

        .xml-link-block::after {
            content: "";
            display: block;
            margin-top: 0.45rem;
            width: 70%;
            height: 1px;
            background: linear-gradient(90deg, rgba(90, 74, 56, 0.6), transparent);
        }

        .cudl-panel {
            padding: 0.9rem;
            border: 1px solid rgba(90, 74, 56, 0.22);
            border-radius: 10px;
            background: #f7efe3;
            height: fit-content;
            --panel-shadow-x: 0px;
            --panel-shadow-y: 14px;
            --panel-shadow-blur: 30px;
            --panel-shadow-alpha: 0.24;
            box-shadow:
                var(--panel-shadow-x) var(--panel-shadow-y) var(--panel-shadow-blur) rgba(35, 28, 20, var(--panel-shadow-alpha)),
                0 4px 10px rgba(35, 28, 20, 0.1);
            transition: box-shadow 0.12s ease-out;
        }

        .cudl-head-row {
            margin: 0 0 0.6rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.7rem;
        }

        .cudl-title {
            margin: 0;
            color: #4c4034;
        }

        .cudl-frame {
            width: 100%;
            height: 72vh;
            min-height: 520px;
            border-radius: 8px;
            background: #fff;
            border: none;
            box-shadow: none;
        }

        .cudl-placeholder {
            width: 100%;
            height: 72vh;
            min-height: 520px;
            border-radius: 8px;
            background-color: #111;
            background-position: center;
            background-size: contain;
            background-repeat: no-repeat;
            background-image: var(--folio-bg-url, url("../../assets/tei_brhat/1r.jpg"));
            border: none;
            box-shadow: none;
        }

        .cudl-link {
            margin-top: 0.5rem;
            font-size: 0.84rem;
            color: #6c5a46;
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            align-items: center;
            gap: 0.8rem;
        }

        .cudl-link a {
            font-size: 0.78rem;
            color: #3f6e9a;
            font-weight: 500;
        }

        .cudl-link a:hover {
            color: #32597b;
        }

        .cudl-link a:last-child {
            justify-self: end;
        }

        .cudl-caption-inline {
            justify-self: center;
            font-size: 0.76rem;
            color: #7b6b57;
            letter-spacing: 0.01em;
            white-space: nowrap;
        }

        .cudl-load-button {
            border: none;
            border-radius: 8px;
            padding: 0.4rem 0.75rem;
            background: #efe7db;
            color: #4a3e30;
            font-family: Georgia, serif;
            cursor: pointer;
            box-shadow: 0 2px 0 rgba(74, 62, 48, 0.18);
        }

        .cudl-load-button:hover {
            background: #ece2d2;
        }

        .cudl-status {
            margin-top: 0.38rem;
            font-size: 0.76rem;
            color: #6c5a46;
            line-height: 1.35;
        }

        .transcription-layout {
            display: grid;
            grid-template-columns: minmax(0, 1.35fr) minmax(0, 1fr);
            gap: 1rem;
            align-items: start;
            margin-top: 1.3rem;
        }

        .transcription-main {
            min-width: 0;
        }

        .folio-chapter-span {
            margin: 0.08rem 0 0.58rem;
            font-size: 0.74rem;
            line-height: 1.35;
            letter-spacing: 0.01em;
            color: #746250;
        }

        .folio-chapter-span strong {
            color: #5c4a36;
            font-weight: 600;
        }

        .transcription-viewer {
            min-width: 0;
            margin-top: -0.5rem;
            border-left: 1px solid rgba(90, 74, 56, 0.28);
            padding-left: 1rem;
        }

        @media (max-width: 1180px) {
            .folio-hero {
                height: clamp(240px, 40vh, 400px);
            }

            .folio-hero-title {
                left: 1rem;
                right: 1rem;
                max-width: none;
                font-size: clamp(1.65rem, 6vw, 2.4rem);
            }

            .transcription-layout {
                grid-template-columns: 1fr;
            }

            .transcription-viewer {
                position: static;
                margin-top: 0;
                margin-bottom: 0.9rem;
                border-left: none;
                padding-left: 0;
            }

            .cudl-frame {
                height: 58vh;
                min-height: 420px;
            }

            .cudl-placeholder {
                height: 58vh;
                min-height: 420px;
            }

            .transcription-tools {
                min-height: auto;
                padding-right: 0;
                gap: 0.94rem;
            }

            .line-interaction-hint {
                position: static;
                transform: none;
                display: block;
                margin-top: 1.15rem;
                white-space: normal;
            }

            .cudl-link {
                grid-template-columns: minmax(0, 1fr) auto minmax(0, 1fr);
                align-items: start;
                gap: 0.45rem;
            }

            .cudl-caption-inline {
                justify-self: center;
                font-size: 0.74rem;
            }

            .cudl-link a:first-child {
                justify-self: start;
                font-size: 0.72rem;
                max-width: 8.8rem;
            }

            .cudl-link a:last-child {
                justify-self: end;
                font-size: 0.72rem;
                max-width: 8.6rem;
                text-align: right;
            }
        }
    </style>
</head>

<body>
    <button id="floatingMenuToggle" class="floating-menu-toggle" type="button" aria-label="Open navigation"
        aria-controls="floatingSideNav" aria-expanded="false">â˜°</button>
    <div id="floatingNavBackdrop" class="floating-nav-backdrop" hidden></div>
    <nav id="floatingSideNav" class="floating-side-nav" aria-label="Primary">
        <a href="../../">Home</a>
        <a href="../../search/">Search</a>
        <a href="../../transcriptions/">Transcriptions</a>
        <a href="../../visualization/">Visualization</a>
        <a href="../../map/">Map</a>
        <a href="../../about/">About</a>
    </nav>

    <main class="tei-page">
        <div class="legacy-back">
            <button id="legacyBackButton" class="legacy-back-button" type="button">Back</button>
        </div>
        <section id="folioHero" class="folio-hero" aria-label="Manuscript folio background navigator">
            <div id="folioHeroImage" class="folio-hero-image"></div>
            <div class="folio-hero-overlay"></div>
            <div id="folioHeroTitle" class="folio-hero-title">Bá¹›hatSaá¹ƒhitÄ (MS Add.2329)</div>
            <button id="folioPrevBtn" class="folio-nav-btn folio-nav-prev" type="button"
                aria-label="Previous folio">â€¹</button>
            <button id="folioNextBtn" class="folio-nav-btn folio-nav-next" type="button"
                aria-label="Next folio">â€º</button>
            <div class="folio-hero-meta"><span id="folioHeroLabel">FOLIO 1R</span></div>
        </section>
        <div class="transcription-layout">
            <div id="transcriptionMain" class="transcription-main">
                <div id="transcriptionTools" class="transcription-tools">
                    <div id="transcriptionSubtitle" class="transcription-subtitle">Transcription Â· 1r</div>
                    <button id="scriptToggleButton" class="script-toggle-button" type="button" data-script-mode="latin">
                        Script: Latin
                    </button>
                    <button id="editorToggleButton" class="script-toggle-button editor-toggle-button" type="button" hidden>
                        Editor: Off
                    </button>
                </div>
                <div id="folioChapterSpan" class="folio-chapter-span" hidden></div>
                <div id="tei-container"></div>
                <span id="lineInteractionHint" class="line-interaction-hint">Tip: single-click a highlighted matched
                    node for details;
                    double-click a line to compare segmented image.</span>
                <div class="xml-link-block">
                    <a href="./1r.xml" target="_blank" rel="noopener">View XML</a>
                </div>
            </div>
            <aside class="transcription-viewer">
                <section class="cudl-panel" aria-labelledby="cudlTitle">
                    <div class="cudl-head-row">
                        <h2 id="cudlTitle" class="cudl-title">CUDL Viewer</h2>
                        <button id="loadCudlViewerButton" class="cudl-load-button" type="button">
                            Load Viewer
                        </button>
                    </div>
                    <div id="cudlPlaceholder" class="cudl-placeholder" aria-label="Manuscript preview image"></div>
                    <iframe id="cudlFrame" class="cudl-frame" loading="lazy" src="about:blank" hidden
                        data-src="https://cudl.lib.cam.ac.uk/view/MS-ADD-02329/1"
                        referrerpolicy="no-referrer-when-downgrade"
                        title="CUDL viewer for Cambridge University Library MS Add.2329 f.1r"></iframe>
                    <div class="cudl-link">
                        <a href="https://cudl.lib.cam.ac.uk/view/MS-ADD-02329/1" target="_blank"
                            rel="noopener noreferrer">
                            Open CUDL page
                        </a>
                        <span class="cudl-caption-inline">Cambridge University Library, MS Add.2329, fol. 1r</span>
                        <a href="../../assets/tei_brhat/1r.jpg" download="MS-Add-2329_fol-1r.jpg">
                            Download image
                        </a>
                    </div>
                    <div id="cudlStatus" class="cudl-status">Tip: static preview by default. Load Viewer for interactive
                        mode.</div>
                </section>
            </aside>
        </div>
    </main>
    <script type="module">
        import { bindNodeHitPopup } from "../../js/nodeEntryPopup.js";

        let brhatAbLineCounter = 0;
        const BRHAT_LINE_IMAGE_BASE = "../../assets/tei_brhat/1r_lines";
        let activeLinePreview = null;
        let activePreviewLineEl = null;
        let transcriptionScriptMode = "latin";
        let transcriptionTextNodes = [];
        let sanskritNodeDataCache = null;
        let sanskritVariantToStemMap = new Map();
        const SANSKRIT_MANUAL_VARIANTS = {
            // Manual lexicon entry point (MVP): add node stem -> explicit variants here.
            candra: ["candra", "candramas", "candramaso", "candrama", "candrah", "candrah", "candraá¹ƒ", "cÄndra", "cÄndrÄá¹‡Äm"]
        };
        const SANSKRIT_BASIC_SUFFIXES = [
            "", "m", "am", "ah", "aá¸¥", "ena", "asya", "e", "o", "au", "at", "an",
            "am", "ena", "ebhyah", "esu", "anam", "nam", "mas", "masa", "maso", "maya", "mayah", "mayam", "ika", "ikam"
        ];
        const FOLIOS = [
            {
                key: "1r",
                image: "../../assets/tei_brhat/1r.jpg",
                xml: "1r.xml",
                hasTei: true,
                cudlPage: 1,
                chapterSpanCompact: "Upanayanadhyayah -> early Samvatsarasutradhyayah",
                chapterSpanTitle: "upanayanÄdhyÄyaá¸¥ -> first half of sÄá¹ƒvatsarasÅ«trÄdhyÄyaá¸¥"
            },
            { key: "1v", image: "../../assets/tei_brhat/1v.jpg", xml: null, hasTei: false, cudlPage: 2 },
            { key: "2r", image: "../../assets/tei_brhat/2r.jpg", xml: null, hasTei: false, cudlPage: 3 },
        ];
        let currentFolioIndex = 0;
        const BRHAT_EDITOR_PARAM = "edit";
        const BRHAT_EDITOR_STORAGE_PREFIX = "brhat_editor_draft_";
        const BRHAT_EDITOR_LOCALHOST = ["localhost", "127.0.0.1", "::1"].includes(window.location.hostname);
        const BRHAT_EDITOR_UNLOCKED = BRHAT_EDITOR_LOCALHOST
            && new URLSearchParams(window.location.search).get(BRHAT_EDITOR_PARAM) === "1";
        let brhatEditorEnabled = false;

        function getCurrentEditorStorageKey() {
            const folio = getCurrentFolio();
            const key = folio?.key || "unknown";
            return `${BRHAT_EDITOR_STORAGE_PREFIX}${key}`;
        }

        function loadEditorDraft() {
            try {
                const raw = localStorage.getItem(getCurrentEditorStorageKey());
                const parsed = JSON.parse(raw || "{}");
                return parsed && typeof parsed === "object" ? parsed : {};
            } catch {
                return {};
            }
        }

        function saveEditorDraft(draft) {
            try {
                localStorage.setItem(getCurrentEditorStorageKey(), JSON.stringify(draft || {}));
            } catch {
                // ignore localStorage failures
            }
        }

        function applyEditorDraftToContainer(container) {
            const draft = loadEditorDraft();
            const lines = Array.from(container.querySelectorAll(".tei-ab-line"));
            lines.forEach((line) => {
                const lineNo = line.getAttribute("data-line-no") || line.dataset.lineNo || "";
                const textWrap = line.querySelector(".tei-ab-line-text");
                if (!(textWrap instanceof HTMLElement) || !lineNo) return;
                const nextText = draft[lineNo];
                if (typeof nextText === "string" && nextText.length) {
                    textWrap.textContent = nextText;
                }
            });
        }

        function saveCurrentEditorDraft(container) {
            const draft = {};
            const lines = Array.from(container.querySelectorAll(".tei-ab-line"));
            lines.forEach((line) => {
                const lineNo = line.getAttribute("data-line-no") || line.dataset.lineNo || "";
                const textWrap = line.querySelector(".tei-ab-line-text");
                if (!(textWrap instanceof HTMLElement) || !lineNo) return;
                draft[lineNo] = (textWrap.textContent || "").trim();
            });
            saveEditorDraft(draft);
        }

        function setBrhatEditorMode(enabled) {
            if (!BRHAT_EDITOR_UNLOCKED) return;
            brhatEditorEnabled = Boolean(enabled);
            const container = document.getElementById("tei-container");
            const button = document.getElementById("editorToggleButton");
            const scriptBtn = document.getElementById("scriptToggleButton");
            if (button instanceof HTMLElement) {
                button.textContent = brhatEditorEnabled ? "Editor: On" : "Editor: Off";
                button.setAttribute("aria-pressed", brhatEditorEnabled ? "true" : "false");
            }
            document.body.classList.toggle("tei-editor-on", brhatEditorEnabled);
            if (scriptBtn instanceof HTMLButtonElement) {
                scriptBtn.disabled = brhatEditorEnabled;
            }
            if (!(container instanceof HTMLElement)) return;

            if (brhatEditorEnabled) {
                if (transcriptionScriptMode !== "latin") applyTranscriptionScriptMode("latin");
                const body = container.querySelector(".tei-body");
                if (body instanceof HTMLElement) {
                    clearExistingSanskritHighlights(body);
                    clearSanskritHitSummary();
                }
            }

            container.querySelectorAll(".tei-ab-line-text").forEach((el) => {
                if (!(el instanceof HTMLElement)) return;
                el.contentEditable = brhatEditorEnabled ? "true" : "false";
                el.spellcheck = false;
            });

            if (!brhatEditorEnabled) {
                saveCurrentEditorDraft(container);
                captureTranscriptionTextNodes(container);
            }
        }

        async function loadTEI(fileName, targetSelector) {
            const target = document.querySelector(targetSelector);
            if (!target) throw new Error("Target element not found: " + targetSelector);

            try {
                const res = await fetch(`./${fileName}`, { headers: { "Accept": "application/xml" } });
                if (!res.ok) throw new Error(`HTTP ${res.status} for ${fileName}`);
                const xmlText = await res.text();

                // Parse XML (TEI usually uses a default namespace)
                // Parse XML and strip namespace manually to preserve all TEI tags
                const parser = new DOMParser();
                let xmlTextNoNS = xmlText.replace(/xmlns="[^"]+"/, "");  // ğŸ‘ˆ å»æ‰é»˜è®¤ namespace
                const xml = parser.parseFromString(xmlTextNoNS, "text/xml");


                // Basic parse error check
                if (xml.getElementsByTagName("parsererror").length) {
                    throw new Error("XML parse error");
                }

                // Render TEI â†’ HTML
                brhatAbLineCounter = 0;
                const html = teiNodeToHTML(xml.documentElement);
                target.innerHTML = "";
                target.appendChild(html);
                applyEditorDraftToContainer(target);
                placeLineInteractionHint(target);
                syncViewerPlacementByViewport();
                bindLineImagePreview(target);
                await runSanskritNodeHighlightMVP(target);
                bindLineHighlightSuppression(target);
                captureTranscriptionTextNodes(target);
                applyTranscriptionScriptMode(transcriptionScriptMode);
                return true;
            } catch (err) {
                console.error(err);
                // Fallback: show raw XML safely
                target.textContent = "Failed to render TEI. Showing raw XML:\n\n" + (err?.message || "");
                try {
                    const res2 = await fetch(`./${fileName}`);
                    const raw = await res2.text();
                    target.textContent += "\n\n" + raw;
                } catch { }
                return false;
            }
        }

        // Minimal TEI â†’ HTML mapping
        function teiNodeToHTML(node) {
            // Text nodes
            console.log("NODE:", node.localName);  // â† è¿™ä¸€è¡Œæ–°åŠ çš„ï¼Œè°ƒè¯•æ ‡ç­¾ç”¨ï¼ˆå³åµŒå¥—çš„XMLç»“æ„èƒ½å¦æ­£ç¡®åœ¨ç½‘é¡µç«¯è¢«æ¸²æŸ“å‡ºæ¥ï¼Œè¿™æ¬¡è§£å†³äº†unclearä¸è¢«æ˜¾ç¤ºä¸ºé—®å·çš„æƒ…å†µï¼‰
            if (node.outerHTML) console.log("RAW:", node.outerHTML);  // â† è¿™ä¸€è¡Œæ–°åŠ çš„ï¼Œä¿ç•™ä¸ºè°ƒè¯•æ¨¡æ¿ï¼Œåœ¨å¤§å‹ XML é¡¹ç›®ä¸­æœ‰åŠ©äºæ’æŸ¥ namespace ä¸¢å¤±ï¼Œå¯æ³¨é‡Šæ‰
            if (node.nodeType === Node.TEXT_NODE) {
                return document.createTextNode(node.nodeValue);
            }

            // Ignore comments and processing instructions
            if (node.nodeType !== Node.ELEMENT_NODE) {
                return document.createDocumentFragment();
            }

            const name = node.localName; // works regardless of TEI namespace
            const frag = document.createDocumentFragment();

            // Helper to render children
            const renderChildren = (parentEl = null) => {
                const container = parentEl || document.createDocumentFragment();
                for (const child of node.childNodes) {
                    container.appendChild(teiNodeToHTML(child));
                }
                return container;
            };

            // Map a few common TEI elements
            switch (name) {
                case "TEI":
                case "teiCorpus": {
                    const wrapper = el("article", "tei-doc");
                    wrapper.appendChild(renderChildren());
                    return wrapper;
                }
                case "teiHeader": {
                    // Skip header in main view but keep title if present
                    const titleStmt = node.getElementsByTagNameNS("*", "titleStmt")[0];
                    const titleEl = titleStmt?.getElementsByTagNameNS("*", "title")[0];
                    if (titleEl) {
                        const h1 = el("h1");
                        h1.textContent = textContentDeep(titleEl);
                        return h1;
                    }
                    return document.createDocumentFragment();
                }
                case "text": {
                    const section = el("section");
                    section.appendChild(renderChildren());
                    return section;
                }
                case "body": {
                    const main = el("div", "tei-body tei-manuscript-grid");
                    main.appendChild(renderChildren());
                    return main;
                }
                case "div": {
                    const div = el("section", "tei-div");
                    // optional head within div
                    const head = node.getElementsByTagNameNS("*", "head")[0];
                    if (head) {
                        const h2 = el("h2");
                        h2.textContent = textContentDeep(head);
                        div.appendChild(h2);
                    }
                    for (const child of node.childNodes) {
                        if (child.nodeType === Node.ELEMENT_NODE && child.localName === "head") continue;
                        div.appendChild(teiNodeToHTML(child));
                    }
                    return div;
                }
                case "p": {
                    const p = el("p");
                    p.appendChild(renderChildren());
                    return p;
                }
                case "ab": {
                    const p = el("p", "tei-line tei-ab-line");
                    brhatAbLineCounter += 1;
                    p.dataset.lineNo = String(brhatAbLineCounter);
                    if (brhatAbLineCounter % 5 === 0) {
                        p.classList.add("tei-ab-major-line");
                    }
                    const textWrap = el("span", "tei-ab-line-text");
                    textWrap.appendChild(renderChildren());
                    p.appendChild(textWrap);
                    return p;
                }
                case "head": {
                    const h2 = el("h2");
                    h2.appendChild(renderChildren());
                    return h2;
                }
                case "lb": {
                    return el("br");
                }
                case "pb": {
                    const span = el("span", "tei-pb");
                    const n = node.getAttribute("n");
                    const facs = node.getAttribute("facs");
                    span.setAttribute("title", n ? `Page break: ${n}` : "Page break");
                    // æ˜¾ç¤ºä¸­æ€§ç¬¦å·ï¼Œé¿å…å’Œ verse bar æ··æ·†
                    span.textContent = n ? ` [${n}] ` : " [pb] ";
                    return span;
                }
                case "note": {
                    const place = node.getAttribute("place");
                    const type = node.getAttribute("type");

                    // éšè—æ¥æºè¯´æ˜ï¼šCambridge University Library...ï¼ˆä¿ç•™åœ¨ XMLï¼Œä¸åœ¨ç½‘é¡µæ­£æ–‡æ˜¾ç¤ºï¼‰
                    if (type === "source") {
                        return document.createDocumentFragment();
                    }

                    // â€”â€” A ç±»ï¼šå†…è”æ³¨é‡Šï¼ˆinlineï¼‰ â€”â€”
                    if (place === "inline") {
                        const span = el("span", "tei-note-inline");
                        span.title = "inline note";   // hover tooltip
                        span.appendChild(renderChildren());
                        return span;
                    }

                    // â€”â€” B ç±»ï¼šæ™®é€šè„šæ³¨ï¼ˆä¿ç•™åŸæ ·ï¼‰ â€”â€”
                    const aside = el("aside", "tei-note");
                    aside.appendChild(renderChildren());
                    return aside;
                }

                case "hi": {
                    const rend = node.getAttribute("rend") || "";
                    const tag = /italic|em/.test(rend) ? "em" : /bold|strong/.test(rend) ? "strong" : "span";
                    const elx = el(tag);
                    elx.appendChild(renderChildren());
                    return elx;
                }
                case "q": {
                    const q = el("blockquote");
                    q.appendChild(renderChildren());
                    return q;
                }
                case "list": {
                    const listType = node.getAttribute("type") || "";
                    const ul = el(listType === "ordered" ? "ol" : "ul");
                    ul.appendChild(renderChildren());
                    return ul;
                }
                case "item": {
                    const li = el("li");
                    li.appendChild(renderChildren());
                    return li;
                }
                case "lg": {
                    const div = el("div", "tei-lg");
                    div.appendChild(renderChildren());
                    return div;
                }
                case "l": {
                    const p = el("p", "tei-line");
                    p.appendChild(renderChildren());
                    return p;
                }
                case "ref": {
                    const a = el("a");
                    const href = node.getAttribute("target") || node.getAttribute("url") || "#";
                    a.href = href;
                    a.appendChild(renderChildren());
                    return a;
                }
                case "gap": {
                    const reason = (node.getAttribute("reason") || "").toLowerCase();
                    if (reason === "ornamental") {
                        const span = el("span", "tei-gap-ornamental");
                        span.textContent = "â—Š";
                        span.setAttribute("title", "Ornamental manuscript gap (layout space, not a word break)");
                        span.setAttribute("aria-label", "ornamental gap");
                        span.setAttribute("tabindex", "0");
                        return span;
                    }
                    // æ˜¾ç¤ºç¼ºå­—ç¬¦å·ï¼Œå¦‚ +++
                    const qty = node.getAttribute("quantity");
                    const span = el("span", "tei-gap");
                    const symbol = "+";
                    span.textContent = qty ? symbol.repeat(Number(qty)) : symbol.repeat(3);
                    return span;
                }

                case "supplied": {
                    // æ˜¾ç¤ºé‡å»ºçš„å†…å®¹ <...>
                    const span = el("span", "tei-supplied");
                    // æ£€æŸ¥æ˜¯å¦åŸæœ¬åŒ…å« <unclear>
                    const hasUnclear = node.getElementsByTagName("unclear").length > 0;
                    const text = textContentDeep(node);
                    if (hasUnclear) {
                        // æ­£å¸¸æ˜¾ç¤º <?à¤ƒ>
                        span.textContent = "<?" + text + ">";
                    } else {
                        // æ²¡æœ‰unclearå­èŠ‚ç‚¹æ—¶ï¼Œä¿ç•™åŸé€»è¾‘
                        span.textContent = "<" + text + ">";
                    }
                    span.setAttribute("title", "Editorially supplied text");
                    return span;
                }

                case "corr": {
                    const corrected = textContentDeep(node);
                    const orig = node.getAttribute("orig") || "11";
                    const resp = node.getAttribute("resp") || "Ling";
                    const note = `Manuscript reads â€œ${orig}â€; corrected to â€œ${corrected}â€ (resp. ${resp})`;
                    const displayValue = orig || corrected;
                    const span = el("span", "tei-corr-marker");
                    span.setAttribute("tabindex", "0");
                    span.setAttribute("title", note);
                    span.textContent = `â€ ${displayValue}â€ `;
                    return span;
                }


                case "unclear": {
                    const span = el("span", "tei-unclear");
                    const text = textContentDeep(node);

                    // console.log("UNCLEAR NODE:", text);  â† è¿™ä¸¤è¡Œæ–°åŠ çš„ï¼Œè°ƒè¯•unclearæ ‡ç­¾åœ¨ç½‘é¡µinspectéƒ¨åˆ†çš„consoleé‡Œdebugç”¨
                    // console.log("FINAL OUTPUT:", `<?${text}>`);  // â† è¿™ä¸¤è¡Œæ–°åŠ çš„ï¼Œä»…ä¸ºdebugè¾“å‡ºç»“æœç”¨

                    if (node.parentNode && node.parentNode.localName === "supplied") {
                        span.textContent = `<?${text}>`;
                    } else {
                        span.textContent = `<${text}>`;
                    }
                    span.setAttribute("title", "Unclear manuscript reading");

                    return span;
                }

                case "facsimile":
                case "surface": {
                    // å½“å‰é¡µé¢ä¸å±•ç¤º facsimile åŒºå—
                    return document.createDocumentFragment();
                }

                case "graphic": {
                    // å½“å‰é¡µé¢ä¸å±•ç¤ºæ‰‹ç¨¿å›¾ç‰‡ï¼Œæ”¹ç”±å³ä¾§ CUDL viewer æä¾›
                    return document.createDocumentFragment();
                }


                case "fw": {
                    // running title/page header ä¸åº”è¯¥æ˜¾ç¤ºåœ¨æ­£æ–‡
                    return document.createDocumentFragment();
                }

                case "desc":
                case "sourceDesc": {
                    // ä¸æ˜¾ç¤ºä»»ä½•æ–‡å­—
                    return document.createDocumentFragment(); // å¿½ç•¥æ˜¾ç¤º
                }

                case "listBibl": {
                    const section = el("section", "tei-bibl");
                    section.appendChild(renderChildren());
                    return section;
                }

                case "bibl": {
                    const p = el("p", "tei-bibl-item");

                    // â€”â€” è¯†åˆ« monograph æ ¼å¼ â€”â€”
                    const isMono = node.querySelector("title[level='m']");

                    if (isMono) {
                        const authors = [...node.querySelectorAll("author")]
                            .map(a => a.textContent.trim())
                            .join("ï¼›");

                        const title = node.querySelector("title[level='m']")?.textContent.trim() || "";
                        const pubPlace = node.querySelector("pubPlace")?.textContent.trim() || "";
                        const publisher = node.querySelector("publisher")?.textContent.trim() || "";
                        const date = node.querySelector("date")?.textContent.trim() || "";
                        const pages = node.querySelector("biblScope[unit='page']")?.textContent.trim() || "";

                        // â€”â€” HTML è¾“å‡ºå¥å­ï¼ˆæœ€ç»ˆç½‘é¡µä¼šå‘ˆç°æˆä½ è¦çš„æ ¼å¼ï¼‰ â€”â€”
                        p.textContent =
                            `${authors}ï¼šã€Š${title}ã€‹ï¼Œ${pubPlace}ï¼š${publisher}ï¼Œ${date}å¹´ç‰ˆï¼Œ${pages ? `ç¬¬ ${pages} é ã€‚` : ""}`;

                        return p;
                    }

                    // â€”â€” å…¶ä»–ç±»å‹çš„ biblï¼ˆå¦‚ journal æ–‡ç« ï¼‰ä¿æŒåŸæœ‰é€»è¾‘ â€”â€”

                    p.appendChild(renderChildren());
                    return p;
                }

                case "biblHead":  // â† æ”¹æˆè‡ªå®šä¹‰æ ‡ç­¾åé¿å…å†²çª
                case "headBibl":  // ä»»é€‰ä¸€ä¸ªï¼Œä¸‹é¢ä¸¤è¡ŒåŠ è¯´æ˜
                    const h3 = el("h3");
                    h3.appendChild(renderChildren());
                    return h3;

                case "title": {
                    const level = node.getAttribute("level") || "";
                    const type = node.getAttribute("type") || "";

                    // æœŸåˆŠå / monograph â†’ æ–œä½“
                    if (level === "j" || level === "m") {
                        const em = el("em", "tei-title");
                        em.appendChild(renderChildren()); // âœ… ä¿ç•™å­èŠ‚ç‚¹ï¼ˆå…è®¸åµŒå¥—ï¼‰
                        return em;
                    }

                    // æ–‡ç« æ ‡é¢˜ â†’ åŠ å¼•å·å¹¶ä¿ç•™å­å…ƒç´ 
                    if (level === "a") {
                        const span = el("span", "tei-title-article");
                        span.appendChild(renderChildren()); // âœ… æ”¹æˆ renderChildren()
                        // è‡ªåŠ¨æ·»åŠ å¼•å·
                        const quoted = el("span");
                        quoted.textContent = "â€œ";
                        span.prepend(quoted);
                        const quotedEnd = el("span");
                        quotedEnd.textContent = "â€";
                        span.appendChild(quotedEnd);
                        return span;
                    }

                    // é»˜è®¤æƒ…å†µ
                    const span = el("span", "tei-title");
                    span.appendChild(renderChildren());
                    return span;
                }


                default: {
                    // Unknown TEI element: render its children inline
                    return renderChildren();
                }
            }
        }

        // Utilities
        function el(tag, className) {
            const e = document.createElement(tag);
            if (className) e.className = className;
            return e;
        }
        function textContentDeep(node) {
            let s = "";
            const walker = document.createTreeWalker(node, NodeFilter.SHOW_TEXT, null);
            let n;
            while ((n = walker.nextNode())) s += n.nodeValue;
            return s.trim();
        }

        function getBasePrefixForData() {
            const path = window.location.pathname || "";
            return path.includes("/transcriptions/") ? path.split("/transcriptions/")[0] : "";
        }

        function escapeHtml(input) {
            return String(input || "")
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#39;");
        }

        function foldSanskritText(input) {
            return String(input || "")
                .toLowerCase()
                .normalize("NFD")
                .replace(/\p{M}+/gu, "")
                .replace(/[^a-z0-9]+/g, " ")
                .replace(/\s+/g, " ")
                .trim();
        }

        function buildFoldedTextWithMap(original) {
            const source = String(original || "");
            let folded = "";
            const map = [];
            let offset = 0;
            for (const ch of source) {
                const piece = foldSanskritText(ch) || " ";
                for (const fp of piece) {
                    folded += fp;
                    map.push(offset);
                }
                offset += ch.length;
            }
            return { folded, map };
        }

        function extractSanskritStemsFromNode(nodeLike) {
            const p = nodeLike?.properties || nodeLike || {};
            const raw = [
                p.transliteration,
                p.name_sa,
                p.name
            ].filter((v) => typeof v === "string" && v.trim());
            const stems = new Set();
            const splitter = /[\s,;/|()[\]{}:]+/;
            for (const value of raw) {
                value.split(splitter).forEach((token) => {
                    const folded = foldSanskritText(token);
                    if (!folded) return;
                    if (!/^[a-z]+$/.test(folded)) return;
                    if (folded.length < 4) return;
                    stems.add(folded);
                });
            }
            return stems;
        }

        function extractSanskritStemDisplayMapFromNode(nodeLike) {
            const p = nodeLike?.properties || nodeLike || {};
            const raw = [
                p.transliteration,
                p.name_sa,
                p.name
            ].filter((v) => typeof v === "string" && v.trim());
            const map = new Map();
            const splitter = /[\s,;/|()[\]{}:]+/;
            for (const value of raw) {
                value.split(splitter).forEach((token) => {
                    const display = String(token || "").trim();
                    const folded = foldSanskritText(display);
                    if (!folded || !/^[a-z]+$/.test(folded) || folded.length < 4) return;
                    if (!map.has(folded)) map.set(folded, display);
                });
            }
            return map;
        }

        function buildSanskritVariantSet(stem) {
            const out = new Set();
            const base = foldSanskritText(stem);
            if (!base || base.length < 4) return out;
            out.add(base);
            SANSKRIT_BASIC_SUFFIXES.forEach((suffix) => {
                const f = foldSanskritText(`${base}${suffix}`);
                if (f) out.add(f);
            });
            const manual = SANSKRIT_MANUAL_VARIANTS[base] || [];
            manual.forEach((v) => {
                const f = foldSanskritText(v);
                if (f) out.add(f);
            });
            return out;
        }

        async function loadSanskritNodeLexiconMVP() {
            const basePrefix = getBasePrefixForData();
            const dataUrl = `${basePrefix}/data.json`;
            const res = await fetch(dataUrl, { headers: { "Accept": "application/json" } });
            if (!res.ok) throw new Error(`HTTP ${res.status} for ${dataUrl}`);
            const data = await res.json();
            const nodes = Array.isArray(data?.nodes) ? data.nodes : [];

            const stems = new Set();
            const stemToDisplay = new Map();
            for (const node of nodes) {
                const itemStems = extractSanskritStemsFromNode(node);
                itemStems.forEach((s) => stems.add(s));
                const displayMap = extractSanskritStemDisplayMapFromNode(node);
                displayMap.forEach((display, stem) => {
                    if (!stemToDisplay.has(stem)) stemToDisplay.set(stem, display);
                });
            }
            Object.keys(SANSKRIT_MANUAL_VARIANTS).forEach((k) => stems.add(foldSanskritText(k)));
            Object.keys(SANSKRIT_MANUAL_VARIANTS).forEach((k) => {
                const folded = foldSanskritText(k);
                if (folded && !stemToDisplay.has(folded)) stemToDisplay.set(folded, k);
            });

            const variants = new Set();
            const variantToStem = new Map();
            stems.forEach((stem) => {
                const forms = buildSanskritVariantSet(stem);
                forms.forEach((f) => {
                    variants.add(f);
                    if (!variantToStem.has(f) || (variantToStem.get(f) || "").length < stem.length) {
                        variantToStem.set(f, stem);
                    }
                });
            });

            // Priority for current MVP focus.
            if (!variants.has("candra")) {
                variants.add("candra");
                variantToStem.set("candra", "candra");
            }
            (SANSKRIT_MANUAL_VARIANTS.candra || []).forEach((v) => {
                const fv = foldSanskritText(v);
                if (!fv) return;
                variants.add(fv);
                if (!variantToStem.has(fv) || (variantToStem.get(fv) || "").length < "candra".length) {
                    variantToStem.set(fv, "candra");
                }
            });

            return {
                stems: Array.from(stems).filter(Boolean),
                variants: Array.from(variants).filter(Boolean),
                variantToStem,
                stemToDisplay
            };
        }

        function clearExistingSanskritHighlights(container) {
            container.querySelectorAll(".tei-node-hit").forEach((mark) => {
                const text = document.createTextNode(mark.textContent || "");
                mark.replaceWith(text);
            });
        }

        function buildVariantRegex(variants) {
            const ordered = Array.from(new Set(variants))
                .filter((v) => typeof v === "string" && v.length >= 4)
                .sort((a, b) => b.length - a.length)
                .map((v) => v.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"));
            if (!ordered.length) return null;
            // MVP: allow compound-internal matches and basic inflection tails.
            return new RegExp(`(${ordered.join("|")}(?:[a-z]{0,10})?)`, "g");
        }

        function highlightSanskritTextNode(textNode, regex, lexicon, rawCounts, groupedCounts) {
            const text = textNode.nodeValue || "";
            const { folded, map } = buildFoldedTextWithMap(text);
            regex.lastIndex = 0;
            const matches = [];
            let m;
            while ((m = regex.exec(folded)) !== null) {
                const term = m[1] || "";
                if (!term) continue;
                const startFolded = m.index;
                const endFolded = startFolded + term.length - 1;
                const stem = (lexicon?.variantToStem?.get(term) || "")
                    || (lexicon?.stems || []).find((s) => term.startsWith(s))
                    || "";
                const startOriginal = map[startFolded];
                const endStart = map[endFolded];
                if (typeof startOriginal !== "number" || typeof endStart !== "number") continue;
                const endOriginalExclusive = endStart + (text[endStart] ? text[endStart].length || 1 : 1);
                matches.push({ start: startOriginal, end: endOriginalExclusive, stem });
            }
            if (!matches.length) return 0;

            matches.sort((a, b) => a.start - b.start || a.end - b.end);
            const merged = [];
            for (const item of matches) {
                const last = merged[merged.length - 1];
                if (!last || item.start >= last.end) {
                    merged.push({ ...item });
                } else if (item.end > last.end) {
                    last.end = item.end;
                }
            }

            const frag = document.createDocumentFragment();
            let cursor = 0;
            let hits = 0;
            for (const seg of merged) {
                if (seg.start > cursor) {
                    frag.appendChild(document.createTextNode(text.slice(cursor, seg.start)));
                }
                const mark = document.createElement("span");
                mark.className = "tei-node-hit";
                mark.textContent = text.slice(seg.start, seg.end);
                mark.title = "Matched node term";
                if (seg.stem) mark.dataset.nodeStem = seg.stem;
                frag.appendChild(mark);
                const form = (mark.textContent || "").trim();
                if (form) {
                    rawCounts.set(form, (rawCounts.get(form) || 0) + 1);
                    const groupKey = seg.stem || foldSanskritText(form) || form;
                    const bucket = groupedCounts.get(groupKey) || { total: 0, forms: new Map() };
                    bucket.total += 1;
                    bucket.forms.set(form, (bucket.forms.get(form) || 0) + 1);
                    groupedCounts.set(groupKey, bucket);
                }
                hits += 1;
                cursor = seg.end;
            }
            if (cursor < text.length) {
                frag.appendChild(document.createTextNode(text.slice(cursor)));
            }
            textNode.parentNode?.replaceChild(frag, textNode);
            return hits;
        }

        function renderSanskritHitSummary(stats) {
            const container = document.querySelector(".xml-link-block") || document.body;
            let block = document.getElementById("sanskritHitSummary");
            if (!block) {
                block = document.createElement("section");
                block.id = "sanskritHitSummary";
                block.className = "node-hit-summary";
                container.insertAdjacentElement("beforebegin", block);
            }

            const items = (stats.groupedTerms || [])
                .map(({ total, primary, forms }) => {
                    const variants = (forms || [])
                        .filter((f) => f.term !== primary)
                        .slice(0, 3)
                        .map((f) => `${f.term} ${f.hits}`)
                        .join(" / ");
                    const variantsHtml = variants ? `<span class="node-hit-variants">${escapeHtml(variants)}</span>` : "";
                    return `<li><code>${escapeHtml(primary)}</code> <span>${total}</span>${variantsHtml}</li>`;
                })
                .join("");

            block.innerHTML = `
                <div class="node-hit-head">
                    <button id="toggleSanskritHitPanel" class="node-hit-toggle-btn" type="button" aria-expanded="false">
                        Matched terms
                    </button>
                </div>
                <section id="sanskritHitPanel" class="node-hit-panel">
                    <details class="node-hit-details" open>
                        <summary>Grouped terms (top 30) Â· ${stats.matchedGroups || 0} groups / ${stats.totalHits || 0} hits</summary>
                        <ul>${items || "<li><em>No matches</em></li>"}</ul>
                    </details>
                </section>
            `;

            const toggle = document.getElementById("toggleSanskritHitPanel");
            const panel = document.getElementById("sanskritHitPanel");
            toggle?.addEventListener("click", () => {
                if (!panel) return;
                const opened = panel.classList.toggle("is-open");
                toggle.setAttribute("aria-expanded", opened ? "true" : "false");
            });
        }

        function clearSanskritHitSummary() {
            const block = document.getElementById("sanskritHitSummary");
            block?.remove();
        }

        async function runSanskritNodeHighlightMVP(container) {
            const root = container.querySelector(".tei-body");
            if (!root) return;
            clearExistingSanskritHighlights(root);
            let lexicon;
            try {
                lexicon = await loadSanskritNodeLexiconMVP();
            } catch (err) {
                console.warn("[Sanskrit highlight MVP] lexicon load failed, fallback to manual variants:", err);
                lexicon = {
                    stems: ["candra"],
                    variants: ["candra", ...(SANSKRIT_MANUAL_VARIANTS.candra || []).map(foldSanskritText)]
                };
            }

            const regex = buildVariantRegex(lexicon.variants);
            if (!regex) return;
            sanskritVariantToStemMap = lexicon.variantToStem || new Map();

            const walker = document.createTreeWalker(
                root,
                NodeFilter.SHOW_TEXT,
                {
                    acceptNode(node) {
                        if (!node.nodeValue || !node.nodeValue.trim()) return NodeFilter.FILTER_REJECT;
                        const parent = node.parentElement;
                        if (!parent) return NodeFilter.FILTER_REJECT;
                        if (parent.closest("h1")) return NodeFilter.FILTER_REJECT;
                        if (parent.closest("script, style, a, button, code, pre, .tei-node-hit, .tei-corr-marker, .tei-supplied, .tei-unclear")) return NodeFilter.FILTER_REJECT;
                        return NodeFilter.FILTER_ACCEPT;
                    }
                }
            );
            const targets = [];
            let n;
            while ((n = walker.nextNode())) targets.push(n);

            let totalHits = 0;
            const rawCounts = new Map();
            const groupedCounts = new Map();
            targets.forEach((textNode) => {
                totalHits += highlightSanskritTextNode(textNode, regex, lexicon, rawCounts, groupedCounts);
            });
            const groupedTerms = Array.from(groupedCounts.entries())
                .map(([key, bucket]) => {
                    const forms = Array.from(bucket.forms.entries())
                        .sort((a, b) => b[1] - a[1] || b[0].length - a[0].length)
                        .map(([term, hits]) => ({ term, hits }));
                    return {
                        key,
                        total: bucket.total,
                        primary: lexicon?.stemToDisplay?.get(key) || key,
                        forms
                    };
                })
                .sort((a, b) => b.total - a.total || (b.forms[0]?.term?.length || 0) - (a.forms[0]?.term?.length || 0))
                .slice(0, 30);
            renderSanskritHitSummary({
                totalHits,
                matchedGroups: groupedCounts.size,
                groupedTerms
            });
            console.log(`[Sanskrit highlight MVP] hits=${totalHits} stems=${lexicon.stems.length} variants=${lexicon.variants.length}`);
            bindSanskritNodePopup(root);
        }

        async function loadSanskritNodeData() {
            if (sanskritNodeDataCache) return sanskritNodeDataCache;
            const dataUrl = `${getBasePrefixForData()}/data.json`;
            const res = await fetch(dataUrl, { headers: { "Accept": "application/json" } });
            if (!res.ok) throw new Error(`HTTP ${res.status} for ${dataUrl}`);
            const data = await res.json();
            sanskritNodeDataCache = Array.isArray(data?.nodes) ? data.nodes : [];
            return sanskritNodeDataCache;
        }

        function resolveStemFromHitElement(hitEl) {
            const direct = foldSanskritText(hitEl.dataset.nodeStem || "");
            if (direct) return direct;
            const folded = foldSanskritText(hitEl.textContent || "");
            if (!folded) return "";
            let best = "";
            sanskritVariantToStemMap.forEach((stem, variant) => {
                if (folded.includes(variant) && variant.length > best.length) best = stem;
            });
            if (best) return best;
            if (folded.includes("candr")) return "candra";
            return folded;
        }

        function findNodeByStem(nodes, stem) {
            if (!stem) return null;
            const score = (node) => {
                const p = node?.properties || {};
                const candidates = [p.transliteration, p.name_sa, p.name, p.name_en, p.original_text_tr]
                    .map((v) => foldSanskritText(v || ""));
                let s = 0;
                if (candidates.some((v) => v === stem)) s += 8;
                if (candidates.some((v) => v.includes(stem))) s += 4;
                if (candidates.some((v) => stem.includes(v) && v.length >= 4)) s += 2;
                if ((node?.labels || []).some((l) => String(l).toLowerCase() === "sanskritsymbol")) s += 3;
                return s;
            };
            let bestNode = null;
            let bestScore = -1;
            for (const node of nodes) {
                const s = score(node);
                if (s > bestScore) {
                    bestScore = s;
                    bestNode = node;
                }
            }
            return bestScore > 0 ? bestNode : null;
        }

        function bindSanskritNodePopup(root) {
            bindNodeHitPopup({
                root,
                panelId: "sanskritNodePanel",
                panelTitle: "Node Details",
                emptyText: "Click a highlighted Sanskrit match to view node details.",
                valueFilter: ({ key }) => key !== "value",
                resolveNode: async ({ hit }) => {
                    const stem = resolveStemFromHitElement(hit);
                    const nodes = await loadSanskritNodeData();
                    return findNodeByStem(nodes, stem);
                }
            });
        }

        function getLineImageSrc(lineNo) {
            const nn = String(lineNo).padStart(2, "0");
            return `${BRHAT_LINE_IMAGE_BASE}/1r_l${nn}.jpg`;
        }

        function captureTranscriptionTextNodes(container) {
            transcriptionTextNodes = [];
            const bodyRoot = container.querySelector(".tei-body") || container;
            const walker = document.createTreeWalker(bodyRoot, NodeFilter.SHOW_TEXT, null);
            let node;
            while ((node = walker.nextNode())) {
                if (!node.nodeValue || !node.nodeValue.trim()) continue;
                transcriptionTextNodes.push({ node, latin: node.nodeValue });
            }
        }

        function transliterateIASTToDevanagari(input) {
            const src = input.toLowerCase();
            const vowelIndependent = {
                a: "à¤…", Ä: "à¤†", i: "à¤‡", Ä«: "à¤ˆ", u: "à¤‰", Å«: "à¤Š",
                á¹›: "à¤‹", á¹: "à¥ ", á¸·: "à¤Œ", á¸¹: "à¥¡", e: "à¤", ai: "à¤", o: "à¤“", au: "à¤”"
            };
            const vowelSigns = {
                a: "", Ä: "à¤¾", i: "à¤¿", Ä«: "à¥€", u: "à¥", Å«: "à¥‚",
                á¹›: "à¥ƒ", á¹: "à¥„", á¸·: "à¥¢", á¸¹: "à¥£", e: "à¥‡", ai: "à¥ˆ", o: "à¥‹", au: "à¥Œ"
            };
            const consonants = {
                kh: "à¤–", gh: "à¤˜", ch: "à¤›", jh: "à¤", á¹­h: "à¤ ", á¸h: "à¤¢", th: "à¤¥", dh: "à¤§", ph: "à¤«", bh: "à¤­",
                k: "à¤•", g: "à¤—", á¹…: "à¤™", c: "à¤š", j: "à¤œ", Ã±: "à¤", á¹­: "à¤Ÿ", á¸: "à¤¡", á¹‡: "à¤£",
                t: "à¤¤", d: "à¤¦", n: "à¤¨", p: "à¤ª", b: "à¤¬", m: "à¤®", y: "à¤¯", r: "à¤°", l: "à¤²", v: "à¤µ",
                Å›: "à¤¶", á¹£: "à¤·", s: "à¤¸", h: "à¤¹", á¸»: "à¤³"
            };
            const marks = { á¹ƒ: "à¤‚", á¹: "à¤‚", á¸¥: "à¤ƒ", "'": "à¤½" };
            const devanagariDigits = { "0": "à¥¦", "1": "à¥§", "2": "à¥¨", "3": "à¥©", "4": "à¥ª", "5": "à¥«", "6": "à¥¬", "7": "à¥­", "8": "à¥®", "9": "à¥¯" };
            const virama = "à¥";
            const vowelTokens = ["ai", "au", "Ä", "Ä«", "Å«", "á¹›", "á¹", "á¸·", "á¸¹", "a", "i", "u", "e", "o"];
            const consonantTokens = ["kh", "gh", "ch", "jh", "á¹­h", "á¸h", "th", "dh", "ph", "bh", "k", "g", "á¹…", "c", "j", "Ã±", "á¹­", "á¸", "á¹‡", "t", "d", "n", "p", "b", "m", "y", "r", "l", "v", "Å›", "á¹£", "s", "h", "á¸»"];
            const readToken = (s, idx) => {
                const two = s.slice(idx, idx + 2);
                if (vowelTokens.includes(two) || consonantTokens.includes(two)) return two;
                return s.slice(idx, idx + 1);
            };

            let out = "";
            let i = 0;
            while (i < src.length) {
                const token = readToken(src, i);
                const step = token.length;

                if (consonants[token]) {
                    const next = readToken(src, i + step);
                    if (vowelSigns[next] !== undefined) {
                        out += consonants[token] + vowelSigns[next];
                        i += step + next.length;
                    } else {
                        out += consonants[token] + virama;
                        i += step;
                    }
                    continue;
                }

                if (vowelIndependent[token]) {
                    out += vowelIndependent[token];
                    i += step;
                    continue;
                }

                if (marks[token]) {
                    out += marks[token];
                    i += step;
                    continue;
                }

                if (devanagariDigits[src[i]]) {
                    out += devanagariDigits[src[i]];
                    i += 1;
                    continue;
                }

                out += src[i];
                i += 1;
            }

            return out;
        }

        function applyTranscriptionScriptMode(mode) {
            transcriptionScriptMode = mode;
            transcriptionTextNodes.forEach((entry) => {
                entry.node.nodeValue = mode === "devanagari"
                    ? transliterateIASTToDevanagari(entry.latin)
                    : entry.latin;
            });
            const digitMap = { "0": "à¥¦", "1": "à¥§", "2": "à¥¨", "3": "à¥©", "4": "à¥ª", "5": "à¥«", "6": "à¥¬", "7": "à¥­", "8": "à¥®", "9": "à¥¯" };
            const lines = document.querySelectorAll(".tei-ab-line");
            lines.forEach((line) => {
                const raw = line.getAttribute("data-line-no") || "";
                const display = mode === "devanagari"
                    ? raw.replace(/[0-9]/g, (d) => digitMap[d] || d)
                    : raw;
                line.setAttribute("data-line-display", display);
            });
            const container = document.getElementById("tei-container");
            container?.classList.toggle("script-devanagari", mode === "devanagari");
            const button = document.getElementById("scriptToggleButton");
            if (!button) return;
            button.dataset.scriptMode = mode;
            button.textContent = mode === "devanagari" ? "Script: Devanagari" : "Script: Latin";
        }

        function closeLinePreview() {
            if (!activeLinePreview) return;
            activeLinePreview.remove();
            activeLinePreview = null;
            if (activePreviewLineEl instanceof HTMLElement) {
                activePreviewLineEl.classList.remove("is-line-preview-active");
            }
            activePreviewLineEl = null;
        }

        function updatePreviewZoom(panel, zoom) {
            const clamped = clamp(zoom, 1, 3);
            panel.dataset.zoom = String(clamped);
            const image = panel.querySelector(".tei-line-preview-image");
            if (image instanceof HTMLElement) {
                image.style.width = `${Math.round(clamped * 100)}%`;
                image.style.maxWidth = "none";
                image.style.transform = "none";
                image.style.cursor = clamped > 1 ? "zoom-out" : "zoom-in";
            }
            const label = panel.querySelector(".tei-line-preview-zoom-label");
            if (label) label.textContent = `${Math.round(clamped * 100)}%`;
        }

        function clamp(value, min, max) {
            return Math.min(max, Math.max(min, value));
        }

        function rectsIntersect(a, b) {
            return !(a.right <= b.left || a.left >= b.right || a.bottom <= b.top || a.top >= b.bottom);
        }

        function initLinePreviewDrag(panel, handle) {
            let dragging = false;
            let offsetX = 0;
            let offsetY = 0;

            const onPointerMove = (evt) => {
                if (!dragging) return;
                const margin = 8;
                const rect = panel.getBoundingClientRect();
                const x = clamp(evt.clientX - offsetX, margin, window.innerWidth - rect.width - margin);
                const y = clamp(evt.clientY - offsetY, margin, window.innerHeight - rect.height - margin);
                panel.style.left = `${x}px`;
                panel.style.top = `${y}px`;
            };

            const stopDrag = () => {
                if (!dragging) return;
                dragging = false;
                panel.classList.remove("is-dragging");
                window.removeEventListener("pointermove", onPointerMove);
                window.removeEventListener("pointerup", stopDrag);
            };

            handle.addEventListener("pointerdown", (evt) => {
                if (evt.button !== 0) return;
                evt.preventDefault();
                const rect = panel.getBoundingClientRect();
                dragging = true;
                offsetX = evt.clientX - rect.left;
                offsetY = evt.clientY - rect.top;
                panel.classList.add("is-dragging");
                window.addEventListener("pointermove", onPointerMove);
                window.addEventListener("pointerup", stopDrag);
            });
        }

        function showLinePreview(lineEl, lineNo) {
            closeLinePreview();
            if (lineEl instanceof HTMLElement) {
                lineEl.classList.add("is-line-preview-active");
                activePreviewLineEl = lineEl;
            }

            const panel = document.createElement("div");
            panel.className = "tei-line-preview";
            panel.setAttribute("role", "dialog");
            panel.setAttribute("aria-label", `Line ${lineNo} image preview`);

            const header = document.createElement("div");
            header.className = "tei-line-preview-header";
            header.textContent = `Line ${lineNo}`;

            const closeButton = document.createElement("button");
            closeButton.className = "tei-line-preview-close";
            closeButton.type = "button";
            closeButton.textContent = "Ã—";
            closeButton.setAttribute("aria-label", "Close line preview");
            closeButton.addEventListener("click", closeLinePreview);

            const controls = document.createElement("div");
            controls.className = "tei-line-preview-controls";

            const zoomOut = document.createElement("button");
            zoomOut.type = "button";
            zoomOut.className = "tei-line-preview-zoom-btn";
            zoomOut.textContent = "âˆ’";
            zoomOut.setAttribute("aria-label", "Zoom out");

            const zoomLabel = document.createElement("span");
            zoomLabel.className = "tei-line-preview-zoom-label";
            zoomLabel.textContent = "100%";

            const zoomIn = document.createElement("button");
            zoomIn.type = "button";
            zoomIn.className = "tei-line-preview-zoom-btn";
            zoomIn.textContent = "+";
            zoomIn.setAttribute("aria-label", "Zoom in");

            controls.appendChild(zoomOut);
            controls.appendChild(zoomLabel);
            controls.appendChild(zoomIn);
            controls.appendChild(closeButton);
            header.appendChild(controls);

            const image = document.createElement("img");
            image.className = "tei-line-preview-image";
            image.src = getLineImageSrc(lineNo);
            image.alt = `Manuscript segmented line ${lineNo}`;
            image.addEventListener("click", () => {
                const current = Number(panel.dataset.zoom || "1");
                updatePreviewZoom(panel, current > 1 ? 1 : 2);
            });
            image.addEventListener("error", () => {
                image.replaceWith(Object.assign(document.createElement("p"), {
                    className: "tei-line-preview-error",
                    textContent: `Line image not found: ${lineNo}`
                }));
            });

            zoomIn.addEventListener("click", () => {
                const current = Number(panel.dataset.zoom || "1");
                updatePreviewZoom(panel, current + 0.25);
            });
            zoomOut.addEventListener("click", () => {
                const current = Number(panel.dataset.zoom || "1");
                updatePreviewZoom(panel, current - 0.25);
            });
            panel.addEventListener("wheel", (event) => {
                if (!event.ctrlKey && !event.metaKey) return;
                event.preventDefault();
                const current = Number(panel.dataset.zoom || "1");
                const delta = event.deltaY < 0 ? 0.12 : -0.12;
                updatePreviewZoom(panel, current + delta);
            }, { passive: false });

            panel.appendChild(header);
            panel.appendChild(image);
            document.body.appendChild(panel);
            activeLinePreview = panel;

            const margin = 12;
            const panelRect = panel.getBoundingClientRect();
            const lineRect = lineEl.getBoundingClientRect();
            const candidates = [
                { left: lineRect.right + margin, top: lineRect.top },
                { left: lineRect.left - panelRect.width - margin, top: lineRect.top },
                { left: lineRect.left, top: lineRect.bottom + margin },
                { left: lineRect.left, top: lineRect.top - panelRect.height - margin },
            ];

            let chosen = null;
            for (const candidate of candidates) {
                const left = clamp(candidate.left, margin, window.innerWidth - panelRect.width - margin);
                const top = clamp(candidate.top, margin, window.innerHeight - panelRect.height - margin);
                const previewRect = {
                    left,
                    top,
                    right: left + panelRect.width,
                    bottom: top + panelRect.height,
                };
                if (!rectsIntersect(previewRect, lineRect)) {
                    chosen = { left, top };
                    break;
                }
            }

            if (!chosen) {
                chosen = {
                    left: clamp(window.innerWidth - panelRect.width - margin, margin, window.innerWidth - panelRect.width - margin),
                    top: margin
                };
            }

            panel.style.left = `${chosen.left}px`;
            panel.style.top = `${chosen.top}px`;
            initLinePreviewDrag(panel, header);
            updatePreviewZoom(panel, 1);
        }

        function bindLineImagePreview(container) {
            const lines = Array.from(container.querySelectorAll(".tei-ab-line"));
            lines.forEach((line) => {
                const lineNo = Number(line.dataset.lineNo || "");
                if (!lineNo) return;
                line.addEventListener("dblclick", (event) => {
                    event.preventDefault();
                    event.stopPropagation();
                    showLinePreview(line, lineNo);
                });
            });
        }

        function bindLineHighlightSuppression(container) {
            const suppressSelectors = [
                ".tei-node-hit",
                ".tei-supplied",
                ".tei-unclear",
                ".tei-corr-marker",
                ".tei-gap-ornamental",
                ".tei-note-inline"
            ].join(",");

            const marks = Array.from(container.querySelectorAll(suppressSelectors));
            marks.forEach((mark) => {
                mark.addEventListener("mouseenter", () => {
                    const line = mark.closest(".tei-ab-line");
                    line?.classList.add("tei-line-hover-blocked");
                });
                mark.addEventListener("mouseleave", () => {
                    const line = mark.closest(".tei-ab-line");
                    line?.classList.remove("tei-line-hover-blocked");
                });
                mark.addEventListener("focusin", () => {
                    const line = mark.closest(".tei-ab-line");
                    line?.classList.add("tei-line-hover-blocked");
                });
                mark.addEventListener("focusout", () => {
                    const line = mark.closest(".tei-ab-line");
                    line?.classList.remove("tei-line-hover-blocked");
                });
            });
        }

        function getCurrentFolio() {
            return FOLIOS[currentFolioIndex];
        }

        function setFolioHeroImage(folio) {
            const heroImage = document.getElementById("folioHeroImage");
            const heroLabel = document.getElementById("folioHeroLabel");
            if (heroImage instanceof HTMLElement) {
                heroImage.style.backgroundImage = `url("${folio.image}")`;
            }
            if (heroLabel) heroLabel.textContent = `FOLIO ${folio.key.toUpperCase()}`;
        }

        function syncHeroTitleFromContent(folio) {
            const heroTitle = document.getElementById("folioHeroTitle");
            const contentTitle = teiContainer?.querySelector("h1");
            if (contentTitle instanceof HTMLElement) {
                contentTitle.classList.add("tei-hidden-title");
            }
            if (heroTitle) {
                heroTitle.textContent = "Bá¹›hatSaá¹ƒhitÄ (MS Add.2329)";
            }
        }

        function placeLineInteractionHint(container) {
            const hint = document.getElementById("lineInteractionHint");
            if (!(hint instanceof HTMLElement)) return;
            const bibl = container?.querySelector?.(".tei-bibl");
            if (bibl instanceof HTMLElement && bibl.parentElement) {
                bibl.parentElement.insertBefore(hint, bibl);
                return;
            }
            const xmlLink = document.querySelector(".xml-link-block");
            if (xmlLink instanceof HTMLElement) {
                xmlLink.insertAdjacentElement("beforebegin", hint);
                return;
            }
            container?.insertAdjacentElement?.("afterend", hint);
        }

        function renderFolioPlaceholder(target, folio) {
            const wrapper = document.createElement("article");
            wrapper.className = "tei-doc";

            const h1 = document.createElement("h1");
            h1.textContent = `Bá¹›hatsaá¹ƒhitÄ (MS Add.2329, fol. ${folio.key})`;
            wrapper.appendChild(h1);

            const toolsHint = document.createElement("p");
            toolsHint.className = "tei-folio-placeholder-note";
            toolsHint.textContent = "Transcription for this folio is not yet available. Placeholder layout shown.";
            wrapper.appendChild(toolsHint);

            const body = document.createElement("div");
            body.className = "tei-body tei-manuscript-grid tei-placeholder-grid";
            for (let i = 1; i <= 19; i += 1) {
                const line = document.createElement("p");
                line.className = "tei-line tei-ab-line";
                if (i % 5 === 0) line.classList.add("tei-ab-major-line");
                line.dataset.lineNo = String(i);
                const text = document.createElement("span");
                text.className = "tei-ab-line-text";
                text.innerHTML = "&nbsp;";
                line.appendChild(text);
                body.appendChild(line);
            }
            wrapper.appendChild(body);

            target.innerHTML = "";
            target.appendChild(wrapper);
            clearSanskritHitSummary();
            placeLineInteractionHint(target);
            captureTranscriptionTextNodes(target);
            applyTranscriptionScriptMode("latin");
            syncViewerPlacementByViewport();
        }

        const scriptToggleButton = document.getElementById("scriptToggleButton");
        scriptToggleButton?.addEventListener("click", () => {
            const nextMode = transcriptionScriptMode === "latin" ? "devanagari" : "latin";
            applyTranscriptionScriptMode(nextMode);
        });
        const editorToggleButton = document.getElementById("editorToggleButton");
        if (editorToggleButton instanceof HTMLElement) {
            editorToggleButton.hidden = !BRHAT_EDITOR_UNLOCKED;
            editorToggleButton.addEventListener("click", () => {
                setBrhatEditorMode(!brhatEditorEnabled);
            });
        }
        document.getElementById("tei-container")?.addEventListener("input", (event) => {
            if (!brhatEditorEnabled) return;
            const target = event.target;
            if (!(target instanceof HTMLElement)) return;
            if (!target.closest(".tei-ab-line-text")) return;
            const editorRoot = document.getElementById("tei-container");
            if (!(editorRoot instanceof HTMLElement)) return;
            saveCurrentEditorDraft(editorRoot);
            captureTranscriptionTextNodes(editorRoot);
        });

        const backButton = document.getElementById("legacyBackButton");
        backButton?.addEventListener("click", () => {
            if (window.history.length > 1) {
                window.history.back();
                return;
            }
            window.location.href = "../../transcriptions/";
        });
        const legacyBack = document.querySelector(".legacy-back");

        function updateBackButtonVisibility(pointerEvent = null) {
            if (!(legacyBack instanceof HTMLElement)) return;
            const nearTopLeft = pointerEvent
                ? pointerEvent.clientX <= 170 && pointerEvent.clientY <= 120
                : false;
            const shouldShow = nearTopLeft || window.scrollY > 40;
            legacyBack.classList.toggle("is-visible", shouldShow);
        }

        document.addEventListener("pointermove", (event) => {
            updateBackButtonVisibility(event);
        });
        window.addEventListener("scroll", () => {
            updateBackButtonVisibility(null);
        }, { passive: true });
        updateBackButtonVisibility(null);

        const viewerMediaQuery = window.matchMedia("(max-width: 1180px)");
        const loadCudlViewerButton = document.getElementById("loadCudlViewerButton");
        const cudlFrame = document.getElementById("cudlFrame");
        const cudlStatus = document.getElementById("cudlStatus");
        const cudlPlaceholder = document.getElementById("cudlPlaceholder");
        const cudlPanel = document.querySelector(".cudl-panel");
        const transcriptionMain = document.getElementById("transcriptionMain");
        const transcriptionTools = document.getElementById("transcriptionTools");
        const folioChapterSpan = document.getElementById("folioChapterSpan");
        const teiContainer = document.getElementById("tei-container");
        const folioHero = document.getElementById("folioHero");
        const folioPrevBtn = document.getElementById("folioPrevBtn");
        const folioNextBtn = document.getElementById("folioNextBtn");
        const cudlOpenLink = document.querySelector(".cudl-link a:first-child");
        const cudlDownloadLink = document.querySelector(".cudl-link a:last-child");
        const cudlCaptionInline = document.querySelector(".cudl-caption-inline");
        const floatingMenuToggle = document.getElementById("floatingMenuToggle");
        const floatingSideNav = document.getElementById("floatingSideNav");
        const floatingNavBackdrop = document.getElementById("floatingNavBackdrop");

        function closeFloatingNav() {
            if (!(floatingSideNav instanceof HTMLElement)) return;
            floatingSideNav.classList.remove("open");
            if (floatingMenuToggle instanceof HTMLElement) {
                floatingMenuToggle.setAttribute("aria-expanded", "false");
                floatingMenuToggle.textContent = "â˜°";
            }
            if (floatingNavBackdrop instanceof HTMLElement) {
                floatingNavBackdrop.classList.remove("open");
                floatingNavBackdrop.hidden = true;
            }
        }

        function openFloatingNav() {
            if (!(floatingSideNav instanceof HTMLElement)) return;
            floatingSideNav.classList.add("open");
            if (floatingMenuToggle instanceof HTMLElement) {
                floatingMenuToggle.setAttribute("aria-expanded", "true");
                floatingMenuToggle.textContent = "Ã—";
            }
            if (floatingNavBackdrop instanceof HTMLElement) {
                floatingNavBackdrop.hidden = false;
                requestAnimationFrame(() => {
                    floatingNavBackdrop.classList.add("open");
                });
            }
        }

        floatingMenuToggle?.addEventListener("click", () => {
            if (!(floatingSideNav instanceof HTMLElement)) return;
            const isOpen = floatingSideNav.classList.contains("open");
            if (isOpen) {
                closeFloatingNav();
            } else {
                openFloatingNav();
            }
        });

        floatingNavBackdrop?.addEventListener("click", closeFloatingNav);
        floatingSideNav?.querySelectorAll("a").forEach((link) => {
            link.addEventListener("click", closeFloatingNav);
        });

        function updateFolioLinks(folio) {
            const viewUrl = `https://cudl.lib.cam.ac.uk/view/MS-ADD-02329/${folio.cudlPage}`;
            if (cudlOpenLink instanceof HTMLAnchorElement) {
                cudlOpenLink.href = viewUrl;
            }
            if (cudlDownloadLink instanceof HTMLAnchorElement) {
                cudlDownloadLink.href = folio.image;
                cudlDownloadLink.download = `MS-Add-2329_fol-${folio.key}.jpg`;
            }
            if (cudlCaptionInline) {
                cudlCaptionInline.textContent = `Cambridge University Library, MS Add.2329, fol. ${folio.key}`;
            }
            if (cudlFrame instanceof HTMLIFrameElement) {
                cudlFrame.dataset.src = viewUrl;
            }
            if (cudlPlaceholder instanceof HTMLElement) {
                cudlPlaceholder.style.setProperty("--folio-bg-url", `url("${folio.image}")`);
            }
        }

        function syncViewerPlacementByViewport() {
            const viewer = document.querySelector(".transcription-viewer");
            const layout = document.querySelector(".transcription-layout");
            const main = document.querySelector(".transcription-main");
            const title = document.querySelector("#tei-container h1");
            if (!viewer || !layout || !main) return;

            // Mobile stacked order: Title -> Viewer -> Transcription body
            if (viewerMediaQuery.matches && title) {
                if (viewer.parentElement !== title.parentElement || viewer.previousElementSibling !== title) {
                    title.insertAdjacentElement("afterend", viewer);
                }
                if (transcriptionTools && viewer.nextElementSibling !== transcriptionTools) {
                    viewer.insertAdjacentElement("afterend", transcriptionTools);
                }
                return;
            }

            // Desktop order: main transcription (left) + viewer (right)
            if (viewer.parentElement !== layout) {
                layout.appendChild(viewer);
            }
            if (transcriptionTools && teiContainer) {
                if (title) {
                    if (transcriptionTools.parentElement !== title.parentElement || transcriptionTools.previousElementSibling !== title) {
                        title.insertAdjacentElement("afterend", transcriptionTools);
                    }
                } else if (transcriptionTools.parentElement !== transcriptionMain) {
                    transcriptionMain.insertBefore(transcriptionTools, teiContainer);
                }
            }
        }

        async function renderCurrentFolio() {
            const folio = getCurrentFolio();
            const subtitle = document.getElementById("transcriptionSubtitle");
            const editorBtn = document.getElementById("editorToggleButton");
            if (subtitle) subtitle.textContent = `Transcription Â· ${folio.key}`;
            if (editorBtn instanceof HTMLElement) {
                editorBtn.hidden = !(BRHAT_EDITOR_UNLOCKED && folio.hasTei && folio.xml);
            }
            if (folioChapterSpan instanceof HTMLElement) {
                if (folio.chapterSpanCompact) {
                    const strong = document.createElement("strong");
                    strong.textContent = "Chapter span: ";
                    const text = document.createElement("span");
                    text.textContent = folio.chapterSpanCompact;
                    if (folio.chapterSpanTitle) text.title = folio.chapterSpanTitle;
                    folioChapterSpan.replaceChildren(strong, text);
                    folioChapterSpan.hidden = false;
                } else {
                    folioChapterSpan.hidden = true;
                    folioChapterSpan.textContent = "";
                }
            }
            setFolioHeroImage(folio);
            updateFolioLinks(folio);
            closeLinePreview();

            if (!folio.hasTei || !folio.xml) {
                renderFolioPlaceholder(teiContainer, folio);
                const button = document.getElementById("scriptToggleButton");
                if (button) {
                    button.dataset.scriptMode = "latin";
                    button.textContent = "Script: Latin";
                    button.disabled = true;
                }
                setBrhatEditorMode(false);
            } else {
                await loadTEI(folio.xml, "#tei-container");
                transcriptionScriptMode = "latin";
                const button = document.getElementById("scriptToggleButton");
                if (button) {
                    button.dataset.scriptMode = "latin";
                    button.textContent = "Script: Latin";
                    button.disabled = false;
                }
                if (brhatEditorEnabled) {
                    setBrhatEditorMode(true);
                }
            }

            syncHeroTitleFromContent(folio);

            if (cudlPlaceholder instanceof HTMLElement) {
                cudlPlaceholder.hidden = false;
            }
            if (cudlFrame instanceof HTMLIFrameElement) {
                cudlFrame.hidden = true;
                cudlFrame.src = "about:blank";
            }
            if (loadCudlViewerButton) loadCudlViewerButton.textContent = "Load Viewer";
            if (cudlStatus) {
                cudlStatus.textContent = "Tip: static preview by default. Load Viewer for interactive mode.";
            }
        }

        function animateFolioSwitch(direction) {
            const heroImage = document.getElementById("folioHeroImage");
            const mainPanel = document.querySelector(".transcription-main");
            const viewerPanel = document.querySelector(".transcription-viewer");
            const isNext = direction > 0;
            const heroStartX = isNext ? 150 : -150;
            const contentStartX = isNext ? -104 : 104;
            if (heroImage instanceof HTMLElement) {
                heroImage.animate(
                    [
                        {
                            transform: `translateX(${heroStartX}px) translateY(var(--hero-parallax, 0px)) scale(1.38)`,
                            opacity: 0.58
                        },
                        {
                            transform: "translateX(0) translateY(var(--hero-parallax, 0px)) scale(1.34)",
                            opacity: 0.96
                        }
                    ],
                    { duration: 560, easing: "cubic-bezier(.18,.78,.2,1)", fill: "both" }
                );
            }
            if (mainPanel instanceof HTMLElement) {
                mainPanel.animate(
                    [
                        { transform: `translateX(${contentStartX}px)`, opacity: 0.7 },
                        { transform: "translateX(0)", opacity: 1 }
                    ],
                    {
                        duration: 620,
                        delay: 0,
                        easing: "cubic-bezier(.2,.72,.12,1)",
                        fill: "both"
                    }
                );
            }
            if (viewerPanel instanceof HTMLElement) {
                viewerPanel.animate(
                    [
                        { transform: `translateX(${contentStartX}px)`, opacity: 0.66 },
                        { transform: "translateX(0)", opacity: 1 }
                    ],
                    {
                        duration: 620,
                        delay: 110,
                        easing: "cubic-bezier(.2,.72,.12,1)",
                        fill: "both"
                    }
                );
            }
        }

        async function switchFolioBy(delta) {
            currentFolioIndex = (currentFolioIndex + delta + FOLIOS.length) % FOLIOS.length;
            await renderCurrentFolio();
            const folio = getCurrentFolio();
            const nextUrl = `${window.location.pathname}?folio=${encodeURIComponent(folio.key)}`;
            window.history.replaceState({}, "", nextUrl);
            animateFolioSwitch(delta > 0 ? 1 : -1);
        }

        if (typeof viewerMediaQuery.addEventListener === "function") {
            viewerMediaQuery.addEventListener("change", syncViewerPlacementByViewport);
        } else {
            viewerMediaQuery.addListener(syncViewerPlacementByViewport);
        }

        function updateHeroParallax() {
            const heroImage = document.getElementById("folioHeroImage");
            if (!(heroImage instanceof HTMLElement) || !(folioHero instanceof HTMLElement)) return;
            const rect = folioHero.getBoundingClientRect();
            const heroDocTop = window.scrollY + rect.top;
            const scrolledPastHeroTop = window.scrollY - heroDocTop;
            // Down-scroll => background also drifts downward, but with small amplitude.
            const offset = clamp(scrolledPastHeroTop * 0.08, -12, 64);
            heroImage.style.setProperty("--hero-parallax", `${offset}px`);
        }

        folioPrevBtn?.addEventListener("click", () => {
            switchFolioBy(-1);
        });
        folioNextBtn?.addEventListener("click", () => {
            switchFolioBy(1);
        });

        window.addEventListener("scroll", updateHeroParallax, { passive: true });
        window.addEventListener("resize", updateHeroParallax);
        document.addEventListener("keydown", (event) => {
            if (event.key === "ArrowLeft") switchFolioBy(-1);
            if (event.key === "ArrowRight") switchFolioBy(1);
            if (event.key === "Escape") closeFloatingNav();
        });

        loadCudlViewerButton?.addEventListener("click", () => {
            if (!(cudlFrame instanceof HTMLIFrameElement)) return;
            const targetSrc = cudlFrame.dataset.src;
            if (!targetSrc) return;
            if (cudlPlaceholder instanceof HTMLElement) {
                cudlPlaceholder.hidden = true;
            }
            cudlFrame.hidden = false;
            // Always allow manual reload when user clicks again.
            cudlFrame.src = targetSrc;
            loadCudlViewerButton.textContent = "Reload Viewer";
            if (cudlStatus) {
                cudlStatus.textContent = "Tip: interactive viewer loaded. Reload only if needed.";
            }
        });

        function setCudlShadow(xPx, yPx, blurPx, alpha) {
            if (!(cudlPanel instanceof HTMLElement)) return;
            cudlPanel.style.setProperty("--panel-shadow-x", `${xPx}px`);
            cudlPanel.style.setProperty("--panel-shadow-y", `${yPx}px`);
            cudlPanel.style.setProperty("--panel-shadow-blur", `${blurPx}px`);
            cudlPanel.style.setProperty("--panel-shadow-alpha", String(alpha));
        }

        function resetCudlShadow() {
            setCudlShadow(0, 14, 30, 0.24);
        }

        function updateCudlShadowByPointer(clientX, clientY) {
            if (!(cudlPanel instanceof HTMLElement)) return;
            const rect = cudlPanel.getBoundingClientRect();
            const cx = rect.left + rect.width / 2;
            const cy = rect.top + rect.height / 2;
            const dx = clientX - cx;
            const dy = clientY - cy;
            const len = Math.hypot(dx, dy) || 1;
            const dirX = dx / len;
            const dirY = dy / len;

            const outX = Math.max(rect.left - clientX, 0, clientX - rect.right);
            const outY = Math.max(rect.top - clientY, 0, clientY - rect.bottom);
            const dist = Math.hypot(outX, outY);
            const intensity = clamp(dist / 460, 0, 1);

            // Virtual light follows cursor: farther pointer => longer/deeper opposite shadow.
            const offset = 10 + intensity * 24;
            const shadowX = -dirX * offset;
            const shadowY = -dirY * offset + 6;
            const blur = 22 + intensity * 24;
            const alpha = 0.2 + intensity * 0.22;
            setCudlShadow(shadowX, shadowY, blur, alpha);
        }

        document.addEventListener("pointermove", (event) => {
            updateCudlShadowByPointer(event.clientX, event.clientY);
        });
        document.addEventListener("pointerleave", resetCudlShadow);
        resetCudlShadow();

        const initialFolioKey = new URLSearchParams(window.location.search).get("folio");
        const initialIndex = FOLIOS.findIndex((f) => f.key === initialFolioKey);
        if (initialIndex >= 0) currentFolioIndex = initialIndex;
        renderCurrentFolio().then(updateHeroParallax);

        document.addEventListener("click", (event) => {
            if (!activeLinePreview) return;
            const target = event.target;
            if (target instanceof Element && target.closest(".tei-line-preview")) return;
            closeLinePreview();
        });
        document.addEventListener("keydown", (event) => {
            if (event.key === "Escape") closeLinePreview();
        });
    </script>

    <style>
        /* Minimal styling */
        .tei-doc {
            line-height: 1.6;
        }

        .tei-hidden-title {
            position: absolute !important;
            width: 1px !important;
            height: 1px !important;
            padding: 0 !important;
            margin: -1px !important;
            overflow: hidden !important;
            clip: rect(0, 0, 0, 0) !important;
            white-space: nowrap !important;
            border: 0 !important;
        }

        .tei-folio-placeholder-note {
            margin: -0.7rem 0 1rem;
            font-size: 0.86rem;
            color: #7b6b57;
            font-style: italic;
        }

        .tei-placeholder-grid .tei-ab-line-text {
            min-width: min(62vw, 720px);
            min-height: 1.05em;
            border-bottom: 1px dashed rgba(90, 74, 56, 0.2);
        }

        #tei-container.script-devanagari .tei-manuscript-grid {
            font-family: "Noto Serif Devanagari", "Nirmala UI", "Kohinoor Devanagari", serif;
            letter-spacing: 0;
        }

        .tei-note {
            font-size: 0.95em;
            padding-left: 0.8rem;
            border-left: 3px solid #ddd;
            margin: 0.5rem 0;
        }

        .tei-pb {
            opacity: 0.6;
            font-size: 0.9em;
        }

        .tei-div {
            margin: 1rem 0;
        }

        .tei-line {
            margin: 0;
        }

        .tei-line-preview {
            position: fixed;
            z-index: 1200;
            width: min(900px, 96vw);
            max-height: 90vh;
            overflow: auto;
            scrollbar-gutter: stable both-edges;
            background: #fffdf9;
            border: 1px solid rgba(90, 74, 56, 0.3);
            border-radius: 10px;
            box-shadow: 0 14px 34px rgba(0, 0, 0, 0.25);
            padding: 0.6rem 0.6rem 1.2rem;
        }

        .tei-line-preview.is-dragging {
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.28);
        }

        .tei-line-preview-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-weight: 600;
            color: #4a3e30;
            margin-bottom: 0.4rem;
            cursor: move;
            user-select: none;
        }

        .tei-line-preview-controls {
            display: inline-flex;
            align-items: center;
            gap: 0.28rem;
        }

        .tei-line-preview-zoom-btn {
            border: 1px solid rgba(90, 74, 56, 0.28);
            background: #f6efe5;
            color: #4a3e30;
            border-radius: 5px;
            width: 1.4rem;
            height: 1.4rem;
            line-height: 1;
            cursor: pointer;
            padding: 0;
            font-size: 0.95rem;
        }

        .tei-line-preview-zoom-label {
            min-width: 2.5rem;
            text-align: center;
            font-size: 0.8rem;
            color: #5a4d3d;
        }

        .tei-line-preview-close {
            border: none;
            background: transparent;
            color: #6a5842;
            cursor: pointer;
            font-size: 1.1rem;
            line-height: 1;
            padding: 0 0.2rem;
        }

        .tei-line-preview-image {
            width: 100%;
            height: auto;
            display: block;
            border-radius: 6px;
            background: #f3ece2;
            margin-bottom: 0.35rem;
            transition: width 0.18s ease;
        }

        .tei-line-preview-error {
            margin: 0.2rem 0 0;
            color: #8b3f1f;
            font-size: 0.9rem;
        }

        .tei-manuscript-grid {
            --line-no-gutter: 3.3rem;
            margin-top: 0.6rem;
            font-size: 0.86rem;
            line-height: 1.55;
            letter-spacing: 0.01em;
            max-width: 100%;
            overflow-x: auto;
            overflow-y: visible;
            scrollbar-gutter: stable;
            padding-bottom: 1.1rem;
            margin-bottom: 0.35rem;
            position: relative;
            box-shadow: none;
        }

        .tei-body {
            padding-left: var(--line-no-gutter);
        }

        .tei-ab-line {
            white-space: nowrap;
            margin: 0;
            position: relative;
            font-variant-ligatures: none;
            width: max-content;
            min-width: 100%;
            transition: color 0.22s ease;
        }

        .tei-ab-line-text {
            position: relative;
            display: inline-block;
        }

        .tei-ab-line-text::after {
            content: "";
            position: absolute;
            left: -0.2rem;
            right: -0.2rem;
            top: -0.04em;
            bottom: -0.02em;
            border-radius: 6px;
            opacity: 0;
            pointer-events: none;
            background:
                radial-gradient(115% 82% at 8% 62%, rgba(255, 225, 170, 0.2), rgba(255, 225, 170, 0) 74%),
                radial-gradient(115% 82% at 92% 62%, rgba(255, 225, 170, 0.2), rgba(255, 225, 170, 0) 74%),
                linear-gradient(180deg,
                    rgba(0, 0, 0, 0) 30%,
                    rgba(245, 206, 139, 0.34) 34%,
                    rgba(245, 206, 139, 0.34) 90%,
                    rgba(0, 0, 0, 0) 94%);
            filter: blur(0.78px);
            transition: opacity 0.6s ease-in-out, filter 0.6s ease-in-out;
        }

        .tei-ab-line:hover:not(.tei-line-hover-blocked),
        .tei-ab-line:focus-within:not(.tei-line-hover-blocked) {
            color: #2f2a25;
        }

        .tei-ab-line:hover:not(.tei-line-hover-blocked) .tei-ab-line-text::after,
        .tei-ab-line:focus-within:not(.tei-line-hover-blocked) .tei-ab-line-text::after,
        .tei-ab-line.is-line-preview-active .tei-ab-line-text::after {
            opacity: 0.6;
            filter: blur(0.62px);
            animation: tei-line-breathe 1.8s ease-in-out infinite alternate;
        }

        .tei-ab-line:not(:hover):not(:focus-within):not(.is-line-preview-active) .tei-ab-line-text::after {
            animation: none;
        }

        .tei-ab-line.is-line-preview-active {
            color: #2f2a25;
        }

        @keyframes tei-line-breathe {
            0% {
                filter: blur(0.58px);
            }

            100% {
                filter: blur(0.76px);
            }
        }

        .tei-ab-line::before {
            content: attr(data-line-display);
            position: absolute;
            left: calc(var(--line-no-gutter) * -1);
            top: 0;
            width: calc(var(--line-no-gutter) - 1.7rem);
            text-align: right;
            color: transparent;
            pointer-events: none;
            transition: color 0.15s ease;
        }

        .tei-ab-line.tei-ab-major-line::before {
            color: #4c4338;
        }

        .tei-body:hover .tei-ab-line::before,
        .tei-body:focus-within .tei-ab-line::before {
            color: #b0aaa1;
        }

        .tei-ab-line+.tei-ab-line {
            margin-top: 0.03rem;
        }

        .tei-body .tei-ab-line:last-child {
            margin-bottom: 0.25rem;
        }

        .tei-gap-ornamental {
            display: inline-block;
            margin: 0 0.18em;
            padding: 0 0.1em;
            font-size: 0.74em;
            line-height: 1;
            color: #7a4e00;
            vertical-align: 0.1em;
            border-radius: 3px;
            cursor: default;
            user-select: none;
            transition: color 0.18s ease, background 0.18s ease;
        }

        .tei-gap-ornamental:hover,
        .tei-gap-ornamental:focus {
            color: #a56300;
            background: linear-gradient(180deg,
                    rgba(0, 0, 0, 0) 40%,
                    rgba(255, 225, 170, 0.32) 40%,
                    rgba(255, 225, 170, 0.32) 92%,
                    rgba(0, 0, 0, 0) 92%);
            outline: none;
        }

        .tei-node-hit {
            color: #6f4a12;
            background:
                linear-gradient(180deg,
                    rgba(255, 236, 189, 0) 46%,
                    rgba(255, 221, 156, 0.58) 46%,
                    rgba(255, 221, 156, 0.58) 100%);
            border-radius: 0.2em;
            padding: 0 0.08em;
            transition: color 0.2s ease, background-color 0.2s ease;
            cursor: pointer;
            border-bottom: 1px dotted rgba(111, 74, 18, 0.45);
        }

        .tei-node-hit:hover,
        .tei-node-hit:focus {
            color: #8a5a1a;
            background-color: rgba(255, 225, 170, 0.34);
            outline: none;
        }

        .tei-corr-marker {
            cursor: default;
            color: #86582b;
            font-weight: 400;
            border-radius: 3px;
            padding: 0 0.08em;
            transition: color 0.18s ease, background 0.18s ease;
            outline: none;
        }

        .tei-corr-marker:hover,
        .tei-corr-marker:focus {
            color: #a56300;
            background: linear-gradient(180deg,
                    rgba(0, 0, 0, 0) 40%,
                    rgba(255, 225, 170, 0.42) 40%,
                    rgba(255, 225, 170, 0.42) 92%,
                    rgba(0, 0, 0, 0) 92%);
        }

        /* â€”â€” inline æ³¨é‡Šï¼šå’Œæ­£æ–‡åŒä¸€è¡Œï¼Œæ— ç°çº¿ â€”â€” */
        .tei-note-inline {
            color: #7a4e00;
            /* æ³¨é‡Šå­—é¢œè‰²ï¼ˆå¯æ”¹ï¼‰ */
            font-size: 0.9em;
            display: inline;
            cursor: pointer;
            padding: 0 0.15em;
            border-radius: 3px;
        }

        /* è‡ªåŠ¨åŠ ä¸­æ‹¬å· */
        .tei-note-inline::before {
            content: "[";
        }

        .tei-note-inline::after {
            content: "]";
        }

        /* hover é«˜äº®æ˜¾ç¤º tooltip */
        .tei-note-inline:hover {
            color: #a56300;
            background-color: rgba(255, 225, 170, 0.3);
        }

        .tei-supplied,
        .tei-unclear {
            color: #7a4e00;
            border-radius: 3px;
            padding: 0 0.12em;
            transition: color 0.18s ease, background 0.18s ease;
        }

        .tei-supplied:hover,
        .tei-unclear:hover {
            color: #a56300;
            background: linear-gradient(180deg,
                    rgba(0, 0, 0, 0) 40%,
                    rgba(255, 225, 170, 0.32) 40%,
                    rgba(255, 225, 170, 0.32) 92%,
                    rgba(0, 0, 0, 0) 92%);
        }


        /* â€”â€” block æ³¨é‡Šï¼ˆè„šæ³¨ï¼‰ä¾ç„¶ä¿æŒç«–çº¿ â€”â€” */
        .tei-note {
            font-size: 0.95em;
            padding-left: 0.8rem;
            border-left: 3px solid #ddd;
            /* ç°ç«–çº¿ä¿ç•™ */
            margin: 0.5rem 0;
        }

        /* è®©è„šæ³¨ç‹¬ç«‹æ¢è¡Œ */
        .tei-note-block {
            display: block;
            margin: 0.5em 0;
        }

        /* Override default graphic style: show as thumbnail */
        .tei-graphic {
            max-width: 180px;
            /* é»˜è®¤ç¼©ç•¥å›¾å®½åº¦ */
            height: auto;
            display: block;
            margin: 1.2em auto;
            border-radius: 6px;
            cursor: zoom-in;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
        }

        /* ç‚¹å‡»åæ”¾å¤§çš„èƒŒæ™¯ */
        .tei-image-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.75);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 99999;
            cursor: zoom-out;
        }

        /* æ”¾å¤§çš„å¤§å›¾ */
        .tei-image-full {
            max-width: 90%;
            max-height: 90%;
            border-radius: 8px;
            box-shadow: 0 0 12px rgba(255, 255, 255, 0.8);
        }

        .tei-bibl {
            margin-top: 2em;
            padding-top: 1.1em;
            position: relative;
        }

        .tei-bibl::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(90, 74, 56, 0.4), transparent);
        }

        .tei-bibl-item {
            margin-left: 1em;
            line-height: 1.6;
        }

        .tei-title {
            font-style: italic;
        }

        .tei-title-article {
            font-style: normal;
        }

        .tei-bibl a {
            color: #3f6e9a;
            font-weight: 400;
        }

        .tei-bibl a:hover {
            color: #32597b;
        }

        .node-hit-head {
            display: flex;
            align-items: center;
            gap: 0.6rem;
            margin-top: 0.45rem;
            margin-bottom: 0.25rem;
            flex-wrap: wrap;
        }

        .node-hit-toggle-btn {
            border: 1px solid rgba(122, 96, 68, 0.28);
            border-radius: 8px;
            background: #f6efe5;
            color: #4f3d29;
            font-family: Georgia, serif;
            font-size: 0.82rem;
            padding: 0.28rem 0.55rem;
            cursor: pointer;
            box-shadow: 0 2px 0 rgba(74, 62, 48, 0.18);
            transition: background-color 0.2s ease, transform 0.15s ease;
        }

        .node-hit-toggle-btn:hover {
            background: #efe5d8;
        }

        .node-hit-toggle-btn:active {
            transform: translateY(1px);
        }

        .node-hit-panel {
            max-height: 0;
            opacity: 0;
            overflow: hidden;
            transform: translateY(-3px);
            transition: max-height 0.32s ease, opacity 0.24s ease, transform 0.24s ease;
        }

        .node-hit-panel.is-open {
            max-height: 520px;
            opacity: 1;
            transform: translateY(0);
        }

        .node-hit-details {
            margin: 0.25rem 0 0.8rem;
            font-size: 0.82rem;
            color: #4b3d2d;
        }

        .node-hit-details summary {
            cursor: pointer;
            font-weight: 600;
            margin-bottom: 0.35rem;
        }

        .node-hit-details ul {
            margin: 0;
            padding-left: 1.1rem;
            columns: 2;
            column-gap: 1.2rem;
        }

        .node-hit-details li {
            list-style: disc;
            background: transparent;
            box-shadow: none;
            padding: 0;
            margin: 0 0 0.2rem 0;
            border-radius: 0;
            break-inside: avoid;
        }

        .node-hit-details code {
            background: rgba(255, 243, 219, 0.65);
            border-radius: 4px;
            padding: 0.02rem 0.24rem;
            font-size: 0.78rem;
        }

        .node-hit-details span {
            color: #7a654a;
            margin-left: 0.25rem;
        }

        .node-hit-variants {
            display: inline-block;
            margin-left: 0.46rem;
            color: #7a654a;
            font-size: 0.74rem;
        }
    </style>

</body>

</html>
